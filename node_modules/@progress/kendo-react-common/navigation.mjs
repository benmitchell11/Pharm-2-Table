/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
class o {
  constructor(t) {
    this.rovingTabIndex = !0, this.update = () => {
    }, this.focusNextIndex = (e, s, n) => {
      const r = s === 1 ? this.next(e, n) : this.previous(e, n);
      return this.focusElement(r, e), r;
    }, this.tabIndex = t.tabIndex || 0, this.root = t.root, this.selectors = t.selectors, this.focusOptions = t.focusOptions || { preventScroll: !0 }, this.rovingTabIndex = t.rovingTabIndex !== void 0 ? t.rovingTabIndex : !0, this.mouseEvents = t.mouseEvents || {}, this.keyboardEvents = t.keyboardEvents || {};
  }
  /**
   * Returns the collection of DOM elements which the module will navigate in.
   */
  get elements() {
    return this.root.current ? Array.from(this.root.current.querySelectorAll(this.selectors.join(","))) : [];
  }
  /**
   * Returns the first navigation DOM element.
   */
  get first() {
    return this.root.current && this.root.current.querySelector(this.selectors.join(",")) || null;
  }
  /**
   * Returns the last navigation DOM element.
   */
  get last() {
    const t = this.elements;
    return t[t.length - 1] || null;
  }
  /**
   * Returns the focused DOM element from the navigation collection of DOM elements.
   */
  get current() {
    return this.elements.find((t) => t.matches(":focus")) || null;
  }
  /**
   * Returns the next DOM element from the navigation collection of DOM elements.
   */
  next(t, e) {
    const s = e ? this.customElements(e) : this.elements;
    let n = s.indexOf(t) + 1;
    return n = n < 0 ? s.length - 1 : n, s[n % s.length];
  }
  /**
   * Returns the previous DOM element from the navigation collection of DOM elements.
   */
  previous(t, e) {
    const s = e ? this.customElements(e) : this.elements;
    let n = s.indexOf(t) - 1;
    return n = n < 0 ? s.length - 1 : n, s[n % s.length];
  }
  /**
   * Focuses the next element from the navigation collection of DOM elements.
   */
  focusNext(t, e) {
    return this.focusNextIndex(t, 1, e);
  }
  /**
   * Focuses the previous element from the navigation collection of DOM elements.
   */
  focusPrevious(t, e) {
    return this.focusNextIndex(t, -1, e);
  }
  /**
   * The keyboard events handler.
   */
  triggerKeyboardEvent(t, e) {
    const s = t.target instanceof Element && t.target.closest(this.selectors.join(",")), n = t.key === " " ? "Space" : t.key, r = t.nativeEvent.type;
    s && this.keyboardEvents[r][n] && this.keyboardEvents[r][n].call(void 0, s, this, t, e);
  }
  /**
   * The mouse events handler.
   */
  triggerMouseEvent(t) {
    const e = t.target instanceof Element && t.target.closest(this.selectors.join(",")), s = t.nativeEvent.type;
    e && this.mouseEvents[s].call(void 0, e, this, t);
  }
  /**
   * Focuses the passed element from the navigation collection of DOM elements.
   */
  focusElement(t, e) {
    t && (e && (this.rovingTabIndex && e.removeAttribute("tabindex"), e.classList.remove("k-focus")), this.rovingTabIndex && t.setAttribute("tabindex", String(this.tabIndex)), t.focus(this.focusOptions));
  }
  customElements(t) {
    return this.root.current ? Array.from(this.root.current.querySelectorAll(t.join(","))) : [];
  }
}
export {
  o as Navigation
};
