/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { getRootParentId as h, isIdZeroLevel as I, getIdWithoutRootParentId as b, getAllShortIds as p, createId as g, EMPTY_ID as C } from "./itemIdUtils.mjs";
import { SortedPublicItemIds as x } from "./SortedPublicItemIds.mjs";
import { getNestedValue as i } from "./misc.mjs";
function P(t, s) {
  const e = i(s, t);
  return !!(e && e.length);
}
function O(t, s) {
  return s.expanded(t) && P(t, s.getChildrenField());
}
function R(t, s, e, n) {
  const u = A([t], s, e, n);
  return u.length ? u[0] : void 0;
}
function A(t, s, e, n) {
  const u = [], r = new x();
  return r.init(t), N(r, s, e, C, u, n), u;
}
function d(t, s, e, n, u) {
  const r = Number(h(s));
  if (r >= t.length)
    return t;
  let o = t, c = t[r];
  return c[n] || (o = t.slice(), c = o[r] = Object.assign({}, c, { [n]: !0 })), I(s) ? e(c) : c[u] && (c[u] = d(c[u], b(s), e, n, u)), o;
}
function W(t, s, e) {
  const n = p(t);
  let u = s;
  for (let r = 0; r < n.length; r++) {
    const o = u[Number(n[r])];
    if (e.disabled(o))
      return !1;
    u = o[e.getChildrenField()];
  }
  return !0;
}
function j(t, s, e, n) {
  return n ? r(t) : u(t, s);
  function u(o, c) {
    let l = [];
    const f = o[e] || [];
    for (let a = 0; a < f.length; a++) {
      const m = g(a, c);
      l.push(m), l = l.concat(u(f[a], m));
    }
    return l;
  }
  function r(o) {
    let c = [];
    const l = o[e] || [];
    for (let f = 0; f < l.length; f++)
      c.push(i(n, l[f])), c = c.concat(r(l[f]));
    return c;
  }
}
function w(t, s, e, n, u) {
  return (t[n] || []).every((o, c) => u.indexOf(e ? i(e, o) : g(c, s)) > -1);
}
function y(t, s, e) {
  const n = [], u = p(t);
  let r = e;
  for (let o = 0; o < u.length - 1 && r; o++) {
    const c = r[Number(u[o])];
    n.push(c), r = c[s];
  }
  return n;
}
function v(t, s, e) {
  const n = e.slice();
  if (I(t))
    n.splice(Number(t), 1);
  else {
    const u = Number(h(t)), r = n[u] = { ...n[u] };
    r[s] = v(b(t), s, r[s]);
  }
  return n;
}
function E(t, s, e, n, u) {
  const r = u.slice();
  if (I(n))
    if (s === "child") {
      const o = r[Number(n)] = { ...r[Number(n)] };
      o[e] ? (o[e] = o[e].slice(), o[e].push(t)) : o[e] = [t];
    } else
      r.splice(Number(n) + (s === "after" ? 1 : 0), 0, t);
  else {
    const o = Number(h(n)), c = r[o] = { ...r[o] };
    c[e] = E(t, s, e, b(n), c[e]);
  }
  return r;
}
function N(t, s, e, n, u, r) {
  for (let o = 0; o < e.length; o++) {
    const c = e[o], l = g(o, n);
    t.hasId(i(s, c)) && u.push(l), P(c, r) && N(t, s, i(r, c), l, u, r);
  }
}
export {
  E as addItem,
  w as areAllDirectChildrenChecked,
  j as getAllDirectIndirectChildrenIds,
  y as getAllParents,
  P as hasChildren,
  W as isEnabledAndAllParentsEnabled,
  O as isItemExpandedAndWithChildren,
  v as removeItem,
  R as resolveItemId,
  A as resolveItemsIds,
  d as updateItem
};
