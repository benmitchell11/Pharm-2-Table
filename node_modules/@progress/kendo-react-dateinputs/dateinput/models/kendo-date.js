/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const r=require("@progress/kendo-date-math"),p=require("./mask.js"),M=require("../utils.js");class y{constructor(t,e,s){this.year=!0,this.month=!0,this.date=!0,this.hours=!0,this.minutes=!0,this.seconds=!0,this.milliseconds=!0,this.leadingZero=null,this.typedMonthPart="",this.knownParts="adHhmMsEy",this.symbols={E:"E",H:"H",M:"M",a:"a",d:"d",h:"h",m:"m",s:"s",y:"y"},this._value=r.getDate(new Date),this.intlProvider=t,this.formatPlaceholder=e,this.format=s,this.monthNames=this.allFormatedMonths()}get intl(){return this.intlProvider()}get value(){return this._value}setValue(t){t?r.isEqual(t,this._value)||(this._value=r.cloneDate(t),this.modifyExisting(!0)):(this._value=r.getDate(new Date),this.modifyExisting(!1))}hasValue(){const t=(e,s)=>e||s.type!=="literal"&&s.type!=="dayperiod"&&this.getExisting(s.pattern[0]);return this.intl.splitDateFormat(this.format).reduce(t,!1)}getDateObject(){for(let t=0;t<this.knownParts.length;t++)if(!this.getExisting(this.knownParts[t]))return null;return r.cloneDate(this.value)}getTextAndFormat(){return this.merge(this.intl.formatDate(this.value,this.format),this.dateFormatString(this.value,this.format))}modifyExisting(t){const e=this.dateFormatString(this.value,this.format).symbols;for(let s=0;s<e.length;s++)this.setExisting(e[s],t)}getExisting(t){switch(t){case"y":return this.year;case"M":case"L":return this.month;case"d":return this.date;case"E":return this.date&&this.month&&this.year;case"h":case"H":return this.hours;case"m":return this.minutes;case"s":return this.seconds;default:return!0}}setExisting(t,e){switch(t){case"y":this.year=e,e===!1&&this._value.setFullYear(2e3);break;case"M":this.month=e,e===!1&&this._value.setMonth(0);break;case"d":this.date=e;break;case"h":case"H":this.hours=e;break;case"m":this.minutes=e;break;case"s":this.seconds=e;break;default:return}}modifyPart(t,e){let s=r.cloneDate(this.value);switch(t){case"y":s.setFullYear(s.getFullYear()+e);break;case"M":s=r.addMonths(this.value,e);break;case"d":case"E":s.setDate(s.getDate()+e);break;case"h":case"H":s.setHours(s.getHours()+e);break;case"m":s.setMinutes(s.getMinutes()+e);break;case"s":s.setSeconds(s.getSeconds()+e);break;case"a":s.setHours(s.getHours()+12*e);break}this.setExisting(t,!0),this._value=s}parsePart(t,e){if(this.resetLeadingZero(),!e)return this.setExisting(t,!1),{value:null};const s=this.intl.formatDate(this.value,this.format),n=this.dateFormatString(this.value,this.format),h=n.symbols;let i=!1,l="",o="",m="";for(let u=0;u<s.length;u++)h[u]===t?(o+=this.getExisting(t)?s[u]:"0",i=!0):i?m+=s[u]:l+=s[u];let a=null;const c=this.matchMonth(e);for(;o.length>0&&o.charAt(0)==="0";)o=o.slice(1);o.length>=4&&(o="");for(let u=0;u<2;u++){let g=o+e,f=parseInt(g,10);if(a=this.intl.parseDate(l+g+m,this.format),!a&&!isNaN(f)&&!isNaN(parseInt(e,10))){if(t==="M"&&!c){const d=f-1;d>-1&&d<12&&(a=r.cloneDate(this.value),a.setMonth(d),a.getMonth()!==d&&(a=r.lastDayOfMonth(r.addMonths(a,-1))))}t==="y"&&(a=r.createDate(parseInt(g,10),this.month?this.value.getMonth():0,this.date?this.value.getDate():1,this.hours?this.value.getHours():0,this.minutes?this.value.getMinutes():0,this.seconds?this.value.getSeconds():0,this.milliseconds?this.value.getMilliseconds():0),this.date&&a.getDate()!==this.value.getDate()&&(a=r.lastDayOfMonth(r.addMonths(a,-1))))}if(a)return this._value=a,this.setExisting(t,!0),{value:this.value};o=""}return c&&(a=this.intl.parseDate(l+c+m,this.format),a)?(this._value=a,this.setExisting(t,!0),{value:this.value}):(e==="0"&&(this.leadingZero=this.isAbbrMonth(n.partMap,t)?null:{[t]:!0},this.setExisting(t,!1)),{value:null})}symbolMap(t){return this.intl.splitDateFormat(this.format).reduce(M.dateSymbolMap,{})[t]}resetLeadingZero(){const t=this.leadingZero!==null;return this.leadingZero=null,t}isAbbrMonth(t,e){const s=this.partPattern(t,e);return s.type==="month"&&s.names}partPattern(t,e){return t.filter(s=>s.pattern.indexOf(e)!==-1)[0]}matchMonth(t){if(this.typedMonthPart+=t.toLowerCase(),this.monthNames.length===0)return"";for(;this.typedMonthPart.length>0;){for(let s=0;s<this.monthNames.length;s++)if(this.monthNames[s].toLowerCase().indexOf(this.typedMonthPart)===0)return this.monthNames[s];const e=parseInt(this.typedMonthPart,10);if(e>=1&&e<=12&&e.toString()===this.typedMonthPart)return this.monthNames[e-1];this.typedMonthPart=this.typedMonthPart.substring(1,this.typedMonthPart.length)}return""}allFormatedMonths(){const t=this.intl.splitDateFormat(this.format);for(let e=0;e<t.length;e++)if(t[e].type==="month"&&t[e].names)return this.intl.dateFormatNames(t[e].names);return[]}dateFormatString(t,e){const s=this.intl.splitDateFormat(e),n=[],h=[];for(let l=0;l<s.length;l++){let o=this.intl.formatDate(t,{pattern:s[l].pattern}).length;for(;o>0;)n.push(this.symbols[s[l].pattern[0]]||"_"),h.push(s[l]),o--}const i=new p.Mask;return i.symbols=n.join(""),i.partMap=h,i}merge(t,e){let s="",n="",h=e.symbols;for(let i=h.length-1;i>=0;i--)if(this.knownParts.indexOf(h[i])===-1||this.getExisting(h[i]))s=t[i]+s,n=h[i]+n;else{const l=h[i];for(;i>=0&&l===h[i];)i--;for(i++,this.leadingZero&&this.leadingZero[l]?s="0"+s:s=this.dateFieldName(e.partMap[i])+s;n.length<s.length;)n=h[i]+n}return{text:s,format:n}}dateFieldName(t){const e=this.formatPlaceholder||"wide";return e[t.type]?e[t.type]:e==="formatPattern"?t.pattern:this.intl.dateFieldName(Object.assign(t,{nameType:e}))}}exports.KendoDate=y;
