/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import t from "prop-types";
import { cloneDate as B } from "@progress/kendo-date-math";
import { Keys as v, classNames as w, getActiveElement as D } from "@progress/kendo-react-common";
import { provideIntlService as E, provideLocalizationService as F, registerForIntl as O, registerForLocalization as R } from "@progress/kendo-react-intl";
import { selectNow as b, messages as y, now as k } from "../messages/index.mjs";
import { TimeList as S } from "./TimeList.mjs";
import { MIN_TIME as M, MAX_TIME as P, MIDNIGHT_DATE as C } from "../utils.mjs";
import { TIME_PART as u } from "./models/TimePart.mjs";
import { isInTimeRange as A, getNow as K, snapTime as L, generateSnappers as x, timeInRange as _ } from "./utils.mjs";
import { Button as $ } from "@progress/kendo-react-buttons";
const p = new RegExp(`${u.hour}|${u.minute}|${u.second}|${u.dayperiod}|literal`), a = class a extends n.Component {
  constructor(i) {
    super(i), this._element = null, this._nowButton = null, this.dateFormatParts = [], this.timeLists = [], this.focus = (s, e) => {
      Promise.resolve().then(() => {
        e && this._nowButton && this._nowButton.element && this._nowButton.element.focus();
        const o = this.timeLists[0];
        !e && this.state.activeListIndex === -1 && !this.hasActiveButton() && o && o.element && o.focus(s);
      });
    }, this.timeFormatReducer = (s, e) => s + e.pattern, this.timeFormatFilter = (s, e, o) => {
      const r = e >= 1 && o[e - 1];
      return r && r && s.type === "literal" ? p.test(r.type || "") : p.test(s.type || "");
    }, this.focusList = (s) => {
      this.timeLists.length && this.timeLists.reduce(this.listReducer, []).map((e) => s === 1 ? e.next : e.prev).map((e) => e && e.element && e.element.focus({ preventScroll: !0 }));
    }, this.listReducer = (s, e, o, r) => s.length || e.props.id !== this.state.activeListIndex ? s : [{
      next: r[o + 1] || e,
      prev: r[o - 1] || e
    }], this.showNowButton = () => !this.hasSteps() && this.props.nowButton && A(K(), this.min, this.max), this.handleKeyDown = (s) => {
      const { keyCode: e } = s;
      switch (e) {
        case v.left:
          s.preventDefault(), this.focusList(
            0
            /* Left */
          );
          return;
        case v.right:
          s.preventDefault(), this.focusList(
            1
            /* Right */
          );
          return;
        default:
          return;
      }
    }, this.handleListBlur = () => {
      this.nextTick(() => {
        this.setState({ activeListIndex: -1 });
      });
    }, this.handleListFocus = (s) => {
      clearTimeout(this.nextTickId), this.setState({
        activeListIndex: s
      });
    }, this.handleChange = (s) => {
      const { onChange: e } = this.props;
      e && e.call(void 0, s);
    }, this.snapTime = L(
      x(this.props.steps, this.props.min || a.defaultProps.min)
    ), this.state = {
      activeListIndex: -1
    }, this.hasActiveButton = this.hasActiveButton.bind(this);
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  get value() {
    return _(
      this.snapTime(B(this.props.value || C)),
      this.min,
      this.max
    );
  }
  get intl() {
    return E(this);
  }
  get min() {
    return this.snapTime(this.props.min || a.defaultProps.min);
  }
  get max() {
    return this.snapTime(this.props.max || a.defaultProps.max);
  }
  get steps() {
    return this.props.steps || a.defaultProps.steps;
  }
  get boundRange() {
    return this.props.boundRange !== void 0 ? this.props.boundRange : a.defaultProps.boundRange;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    clearTimeout(this.nextTickId);
  }
  componentDidMount() {
    const { onMount: i } = this.props;
    i && i.call(void 0, this.value);
  }
  /**
   * @hidden
   */
  render() {
    const {
      format: i,
      smoothScroll: s,
      onNowClick: e,
      className: o,
      disabled: r,
      mobileMode: d,
      show: I,
      onNowKeyDown: T
    } = this.props;
    this.snapTime = L(x(this.steps, this.min)), this.dateFormatParts = this.intl.splitDateFormat(i || a.defaultProps.format).filter(this.timeFormatFilter);
    const N = w(
      {
        "k-disabled": r,
        "k-time-part": d
      },
      o
    );
    this.timeLists = [];
    const f = F(this), g = f.toLanguageString(b, y[b]);
    return /* @__PURE__ */ n.createElement("div", { className: N }, /* @__PURE__ */ n.createElement("div", { className: "k-time-header" }, /* @__PURE__ */ n.createElement("span", { className: "k-title" }, this.intl.formatDate(this.value, this.dateFormatParts.reduce(this.timeFormatReducer, ""))), this.showNowButton() && /* @__PURE__ */ n.createElement(
      $,
      {
        type: "button",
        ref: (m) => {
          this._nowButton = m;
        },
        className: "k-time-now",
        fillMode: "flat",
        themeColor: "primary",
        title: g,
        onKeyDown: T,
        "aria-label": g,
        onClick: e,
        tabIndex: r ? -1 : 0
      },
      f.toLanguageString(k, y[k])
    )), /* @__PURE__ */ n.createElement(
      "div",
      {
        className: "k-time-list-container",
        onKeyDown: this.handleKeyDown
      },
      /* @__PURE__ */ n.createElement("span", { className: "k-time-highlight" }),
      this.dateFormatParts.map((m, l) => m.type !== "literal" ? /* @__PURE__ */ n.createElement(
        "div",
        {
          key: l,
          className: w("k-time-list-wrapper", {
            "k-focus": l === this.state.activeListIndex
          }),
          role: "presentation",
          tabIndex: -1
        },
        /* @__PURE__ */ n.createElement("span", { className: "k-title", onMouseDown: (h) => {
          h.preventDefault();
        } }, this.intl.dateFieldName(m)),
        /* @__PURE__ */ n.createElement(
          S,
          {
            min: this.min,
            max: this.max,
            boundRange: this.boundRange,
            part: m,
            step: m.type ? this.steps[m.type] : 1,
            smoothScroll: s,
            ref: (h) => {
              h && this.timeLists.push(h);
            },
            id: l,
            onFocus: () => {
              this.handleListFocus(l);
            },
            onBlur: this.handleListBlur,
            onChange: this.handleChange,
            value: this.value,
            disabled: r,
            show: I,
            mobileMode: d
          }
        )
      ) : /* @__PURE__ */ n.createElement(
        "div",
        {
          key: l,
          className: "k-time-separator"
        },
        m.pattern
      ))
    ));
  }
  nextTick(i) {
    clearTimeout(this.nextTickId), this.nextTickId = window.setTimeout(() => i());
  }
  hasActiveButton() {
    const i = D(document);
    return this._nowButton && i === this._nowButton.element;
  }
  hasSteps() {
    const i = Object.keys(this.steps);
    return i.length !== i.reduce((s, e) => s + this.steps[e], 0);
  }
};
a.propTypes = {
  cancelButton: t.bool,
  disabled: t.bool,
  format: t.oneOfType([
    t.string,
    t.shape({
      skeleton: t.string,
      pattern: t.string,
      date: t.oneOf(["short", "medium", "long", "full"]),
      time: t.oneOf(["short", "medium", "long", "full"]),
      datetime: t.oneOf(["short", "medium", "long", "full"]),
      era: t.oneOf(["narrow", "short", "long"]),
      year: t.oneOf(["numeric", "2-digit"]),
      month: t.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: t.oneOf(["numeric", "2-digit"]),
      weekday: t.oneOf(["narrow", "short", "long"]),
      hour: t.oneOf(["numeric", "2-digit"]),
      hour12: t.bool,
      minute: t.oneOf(["numeric", "2-digit"]),
      second: t.oneOf(["numeric", "2-digit"]),
      timeZoneName: t.oneOf(["short", "long"])
    })
  ]),
  max: t.instanceOf(Date),
  min: t.instanceOf(Date),
  nowButton: t.bool,
  steps: t.shape({
    hour: t.number,
    minute: t.number,
    second: t.number
  }),
  smoothScroll: t.bool,
  tabIndex: t.number,
  value: t.instanceOf(Date),
  show: t.bool
}, a.defaultProps = {
  value: null,
  disabled: !1,
  nowButton: !0,
  cancelButton: !0,
  format: "hh:mm a",
  min: M,
  max: P,
  steps: {},
  boundRange: !1
};
let c = a;
O(c);
R(c);
export {
  c as TimePart
};
