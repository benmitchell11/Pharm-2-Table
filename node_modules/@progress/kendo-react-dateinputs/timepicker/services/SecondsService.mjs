/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { isEqual as c } from "@progress/kendo-date-math";
import { MIDNIGHT_DATE as p } from "../../utils.mjs";
import { setSeconds as r, range as x } from "../utils.mjs";
const m = 60, l = (n) => (t) => t % n, g = l(m), S = (n, t) => (s) => g(n + s * t), a = (n, t) => g(m + n - t), u = (n) => (t, s) => !s || t.getMinutes() === s.getMinutes() && t.getHours() === s.getHours() ? t : r(t, n), I = u(0), L = u(m - 1);
class D {
  constructor(t) {
    this.intl = t, this.toListItem = null, this.min = null, this.max = null, this.step = 0, this.insertUndividedMax = !1;
  }
  apply(t, s) {
    return r(t, s.getSeconds());
  }
  configure(t) {
    const {
      insertUndividedMax: s = this.insertUndividedMax,
      min: i = this.min,
      max: o = this.max,
      part: e,
      step: h = this.step
    } = t;
    this.insertUndividedMax = s, this.toListItem = (M) => {
      const d = r(p, M);
      return {
        text: this.intl.formatDate(d, e.pattern),
        value: d
      };
    }, this.min = i, this.max = o, this.step = h;
  }
  data(t) {
    const [s] = this.range(t), i = S(s, this.step), o = (h) => this.toListItem && this.toListItem(i(h)), e = x(0, this.countFromMin(t)).map(o);
    return this.addLast(e), t && this.addMissing(e, t), e;
  }
  isRangeChanged(t, s) {
    return this.min !== null && this.max !== null && (!c(this.min, t) || !c(this.max, s));
  }
  limitRange(t, s, i) {
    return [I(t, i), L(s, i)];
  }
  total(t) {
    const s = this.insertUndividedMax && this.isLastMissing(t) ? 1 : 0, i = this.isMissing(t) ? 1 : 0;
    return this.countFromMin(t) + i + s;
  }
  selectedIndex(t) {
    return Math.ceil(this.divideByStep(t));
  }
  valueInList(t) {
    return t ? this.insertUndividedMax && this.lastSecond(t) === t.getSeconds() || !this.isMissing(t) : !0;
  }
  divideByStep(t) {
    return a(t.getSeconds(), this.min.getSeconds()) / this.step;
  }
  addLast(t, s) {
    return this.insertUndividedMax && this.isLastMissing(s) && this.toListItem && t.push(this.toListItem(this.lastSecond(s))), t;
  }
  addMissing(t, s) {
    if (this.valueInList(s))
      return t;
    if (this.toListItem) {
      const i = this.toListItem(s.getSeconds());
      t.splice(this.selectedIndex(s), 0, i);
    }
    return t;
  }
  countFromMin(t) {
    const [s, i] = this.range(t);
    return Math.floor(a(i, s) / this.step) + 1;
  }
  isMissing(t) {
    return t ? this.selectedIndex(t) !== this.divideByStep(t) : !1;
  }
  isLastMissing(t) {
    return this.max !== null && this.isMissing(r(this.max, this.lastSecond(t)));
  }
  lastSecond(t) {
    return this.range(t)[1];
  }
  range(t) {
    const [s, i] = this.limitRange(this.min, this.max, t);
    return [s.getSeconds(), i.getSeconds()];
  }
}
export {
  D as SecondsService
};
