/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { cloneDate as c } from "@progress/kendo-date-math";
const o = (s, t) => {
  const n = c(s);
  return n.setHours(t), n;
}, m = (s) => s !== null && s < 12, l = (s) => s !== null && (!s || s > 11), g = (s, t, n) => !t && !n || s >= t && s <= n, d = (s, t, n) => !t && !n || s >= t || s <= n;
class H {
  constructor(t) {
    this.intl = t, this.min = null, this.max = null, this.part = null;
  }
  /**
   * @hidden
   */
  apply(t, n) {
    const i = t.getHours(), e = m(i), r = m(n.getHours());
    if (e && r || !e && !r)
      return t;
    const [a, h = 24] = this.normalizedRange(), u = i + (r ? -12 : 12);
    return o(t, Math.min(Math.max(a, u), h || 24));
  }
  /**
   * @hidden
   */
  configure(t) {
    const { min: n = this.min, max: i = this.max, part: e = this.part } = t;
    this.min = n, this.max = i, this.part = e;
  }
  /**
   * @hidden
   */
  data(t) {
    const n = this.part && this.part.names;
    if (!n || !this.min)
      return [];
    const i = [], [e, r] = this.normalizedRange(), a = this.intl.dateFormatNames(n);
    return m(e) && i.push({ text: a.am, value: o(this.min, e) }), l(r) && i.push({ text: a.pm, value: o(this.min, Math.max(12, r)) }), this.min.getHours() !== e ? i.reverse() : i;
  }
  /**
   * @hidden
   */
  isRangeChanged(t, n) {
    return !1;
  }
  /**
   * @hidden
   */
  limitRange(t, n, i) {
    return [t, n];
  }
  /**
   * @hidden
   */
  total() {
    const [t, n] = this.normalizedRange();
    return !t && !n ? 2 : t > 11 || n < 12 ? 1 : 2;
  }
  /**
   * @hidden
   */
  selectedIndex(t) {
    if (!this.valueInList(t) || !this.min)
      return -1;
    const n = Math.floor(t.getHours() / 12);
    return this.min.getHours() === this.normalizedRange()[0] ? n : n === 0 ? 1 : 0;
  }
  /**
   * @hidden
   */
  valueInList(t) {
    return !this.min || !this.max ? !1 : (this.min.getHours() !== this.normalizedRange()[0] ? d : g)(t.getHours(), this.min.getHours(), this.max.getHours());
  }
  normalizedRange() {
    const t = this.min.getHours(), n = this.max.getHours();
    return [
      Math.min(t, n),
      Math.max(t, n)
    ];
  }
}
export {
  H as DayPeriodService
};
