/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { isEqual as u } from "@progress/kendo-date-math";
import { MIDNIGHT_DATE as p } from "../../utils.mjs";
import { setMinutes as r, range as x } from "../utils.mjs";
const m = 60, l = (n) => (t) => t % n, M = l(m), I = (n, t) => (i) => M(n + i * t), d = (n, t) => M(m + n - t), c = (n) => (t, i) => !i || t.getHours() === i.getHours() ? t : r(t, n), L = c(0), f = c(m - 1);
class S {
  constructor(t) {
    this.intl = t, this.toListItem = null, this.min = null, this.max = null, this.step = 0, this.insertUndividedMax = !1;
  }
  apply(t, i) {
    return r(t, i.getMinutes());
  }
  configure(t) {
    const {
      insertUndividedMax: i = this.insertUndividedMax,
      min: s = this.min,
      max: h = this.max,
      part: e,
      step: o = this.step
    } = t;
    this.insertUndividedMax = i, this.toListItem = (g) => {
      const a = r(p, g);
      return {
        text: this.intl.formatDate(a, e.pattern),
        value: a
      };
    }, this.min = s, this.max = h, this.step = o;
  }
  data(t) {
    const [i] = this.range(t), s = I(i, this.step), h = (o) => this.toListItem && this.toListItem(s(o)), e = x(0, this.countFromMin(t)).map(h);
    return this.addLast(e), t && this.addMissing(e, t), e;
  }
  isRangeChanged(t, i) {
    return this.min !== null && this.max !== null && (!u(this.min, t) || !u(this.max, i));
  }
  limitRange(t, i, s) {
    return [L(t, s), f(i, s)];
  }
  total(t) {
    const i = this.insertUndividedMax && this.isLastMissing(t) ? 1 : 0, s = this.isMissing(t) ? 1 : 0;
    return this.countFromMin(t) + s + i;
  }
  selectedIndex(t) {
    return Math.ceil(this.divideByStep(t));
  }
  valueInList(t) {
    return t ? this.insertUndividedMax && this.lastMinute(t) === t.getMinutes() || !this.isMissing(t) : !0;
  }
  addLast(t, i) {
    return this.insertUndividedMax && this.isLastMissing(i) && this.toListItem && t.push(this.toListItem(this.lastMinute(i))), t;
  }
  addMissing(t, i) {
    if (this.valueInList(i))
      return t;
    if (this.toListItem) {
      const s = this.toListItem(i.getMinutes());
      t.splice(this.selectedIndex(i), 0, s);
    }
    return t;
  }
  countFromMin(t) {
    const [i, s] = this.range(t);
    return Math.floor(d(s, i) / this.step) + 1;
  }
  isMissing(t) {
    return t ? this.selectedIndex(t) !== this.divideByStep(t) : !1;
  }
  isLastMissing(t) {
    return this.max !== null && this.isMissing(r(this.max, this.lastMinute(t)));
  }
  divideByStep(t) {
    return d(t.getMinutes(), this.min.getMinutes()) / this.step;
  }
  lastMinute(t) {
    return this.range(t)[1];
  }
  range(t) {
    const [i, s] = this.limitRange(this.min, this.max, t);
    return [i.getMinutes(), s.getMinutes()];
  }
}
export {
  S as MinutesService
};
