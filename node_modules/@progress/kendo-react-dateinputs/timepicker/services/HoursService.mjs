/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import { isEqual as d, getDate as u } from "@progress/kendo-date-math";
import { MIDNIGHT_DATE as l } from "../../utils.mjs";
import { setHours as r, range as I } from "../utils.mjs";
const a = 24, f = (n) => (t) => t % n, g = f(a), H = (n, t) => (i) => g(n + i * t), c = (n, t) => g(a + n - t), p = (n) => (t, i) => !i || u(t).getTime() === u(i).getTime() ? t : r(t, n), L = p(0), R = p(a - 1);
class B {
  constructor(t) {
    this.intl = t, this.boundRange = !1, this.insertUndividedMax = !1, this.min = null, this.max = null, this.step = 0, this.toListItem = null;
  }
  apply(t, i) {
    return r(t, i.getHours());
  }
  configure(t) {
    const {
      boundRange: i = this.boundRange,
      insertUndividedMax: s = this.insertUndividedMax,
      min: o = this.min,
      max: e = this.max,
      part: h,
      step: M = this.step
    } = t;
    this.boundRange = i, this.insertUndividedMax = s, this.toListItem = (x) => {
      const m = r(l, x);
      return {
        text: this.intl.formatDate(m, h.pattern),
        value: m
      };
    }, this.min = o, this.max = e, this.step = M;
  }
  data(t) {
    const [i] = this.range(t), s = H(i, this.step), o = (h) => this.toListItem && this.toListItem(s(h)), e = I(0, this.countFromMin(t)).map(o);
    return this.addLast(e), t && this.addMissing(e, t), e;
  }
  isRangeChanged(t, i) {
    return !this.min || !this.max ? !1 : !d(this.min, t) || !d(this.max, i);
  }
  limitRange(t, i, s) {
    return this.boundRange ? [L(t, s), R(i, s)] : [t, i];
  }
  total(t) {
    const i = this.insertUndividedMax && this.isLastMissing(t) ? 1 : 0, s = this.isMissing(t) ? 1 : 0;
    return this.countFromMin(t) + s + i;
  }
  selectedIndex(t) {
    return Math.ceil(this.divideByStep(t));
  }
  valueInList(t) {
    return t ? this.insertUndividedMax && this.lastHour(t) === t.getHours() || !this.isMissing(t) : !0;
  }
  addLast(t, i) {
    return this.insertUndividedMax && this.isLastMissing(i) && this.toListItem && t.push(this.toListItem(this.lastHour(i))), t;
  }
  addMissing(t, i) {
    if (this.valueInList(i))
      return t;
    if (this.toListItem) {
      const s = this.toListItem(i.getHours());
      t.splice(this.selectedIndex(i), 0, s);
    }
    return t;
  }
  countFromMin(t) {
    const [i, s] = this.range(t);
    return Math.floor(c(s, i) / this.step) + 1;
  }
  isMissing(t) {
    return t ? this.selectedIndex(t) !== this.divideByStep(t) : !1;
  }
  isLastMissing(t) {
    return this.max !== null && this.isMissing(r(this.max, this.lastHour(t)));
  }
  divideByStep(t) {
    return c(t.getHours(), this.min.getHours()) / this.step;
  }
  lastHour(t) {
    return this.range(t)[1];
  }
  range(t) {
    const [i, s] = this.limitRange(this.min, this.max, t);
    return [i.getHours(), s.getHours()];
  }
}
export {
  B as HoursService
};
