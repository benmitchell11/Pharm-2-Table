/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("@progress/kendo-date-math"),l=require("../../utils.js"),r=require("../utils.js"),a=60,x=n=>t=>t%n,c=x(a),p=(n,t)=>i=>c(n+i*t),M=(n,t)=>c(a+n-t),d=n=>(t,i)=>!i||t.getHours()===i.getHours()?t:r.setMinutes(t,n),I=d(0),L=d(a-1);class f{constructor(t){this.intl=t,this.toListItem=null,this.min=null,this.max=null,this.step=0,this.insertUndividedMax=!1}apply(t,i){return r.setMinutes(t,i.getMinutes())}configure(t){const{insertUndividedMax:i=this.insertUndividedMax,min:s=this.min,max:h=this.max,part:e,step:o=this.step}=t;this.insertUndividedMax=i,this.toListItem=g=>{const u=r.setMinutes(l.MIDNIGHT_DATE,g);return{text:this.intl.formatDate(u,e.pattern),value:u}},this.min=s,this.max=h,this.step=o}data(t){const[i]=this.range(t),s=p(i,this.step),h=o=>this.toListItem&&this.toListItem(s(o)),e=r.range(0,this.countFromMin(t)).map(h);return this.addLast(e),t&&this.addMissing(e,t),e}isRangeChanged(t,i){return this.min!==null&&this.max!==null&&(!m.isEqual(this.min,t)||!m.isEqual(this.max,i))}limitRange(t,i,s){return[I(t,s),L(i,s)]}total(t){const i=this.insertUndividedMax&&this.isLastMissing(t)?1:0,s=this.isMissing(t)?1:0;return this.countFromMin(t)+s+i}selectedIndex(t){return Math.ceil(this.divideByStep(t))}valueInList(t){return t?this.insertUndividedMax&&this.lastMinute(t)===t.getMinutes()||!this.isMissing(t):!0}addLast(t,i){return this.insertUndividedMax&&this.isLastMissing(i)&&this.toListItem&&t.push(this.toListItem(this.lastMinute(i))),t}addMissing(t,i){if(this.valueInList(i))return t;if(this.toListItem){const s=this.toListItem(i.getMinutes());t.splice(this.selectedIndex(i),0,s)}return t}countFromMin(t){const[i,s]=this.range(t);return Math.floor(M(s,i)/this.step)+1}isMissing(t){return t?this.selectedIndex(t)!==this.divideByStep(t):!1}isLastMissing(t){return this.max!==null&&this.isMissing(r.setMinutes(this.max,this.lastMinute(t)))}divideByStep(t){return M(t.getMinutes(),this.min.getMinutes())/this.step}lastMinute(t){return this.range(t)[1]}range(t){const[i,s]=this.limitRange(this.min,this.max,t);return[i.getMinutes(),s.getMinutes()]}}exports.MinutesService=f;
