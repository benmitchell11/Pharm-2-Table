/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import e from "prop-types";
import { Popup as L } from "@progress/kendo-react-popup";
import { getDate as W, cloneDate as O } from "@progress/kendo-date-math";
import { classNames as M, Keys as r, validatePackage as _, canUseDOM as P, AsyncFocusBlur as K, kendoThemeMaps as T, createPropsContext as U, withIdHOC as $, withPropsContext as H } from "@progress/kendo-react-common";
import { calendarIcon as X } from "@progress/kendo-svg-icons";
import { packageMetadata as Z } from "../package-metadata.mjs";
import { DateInput as j } from "../dateinput/DateInput.mjs";
import { Calendar as G } from "../calendar/components/Calendar.mjs";
import { MAX_DATE as J, MIN_DATE as Q, isInDateRange as Y, setTime as ee } from "../utils.mjs";
import { toggleCalendar as E, messages as te } from "../messages/index.mjs";
import { provideLocalizationService as ie, registerForLocalization as se } from "@progress/kendo-react-intl";
import { ToggleButton as oe } from "./ToggleButton.mjs";
import { PickerWrap as ae } from "../common/PickerWrap.mjs";
import { PickerFloatingLabel as ne } from "../hooks/usePickerFloatingLabel.mjs";
import { ActionSheetContent as re } from "@progress/kendo-react-layout";
import { AdaptiveMode as le } from "../common/AdaptiveMode.mjs";
import { MOBILE_MEDIUM_DEVISE as de } from "../common/constants.mjs";
const o = class o extends n.Component {
  constructor(i) {
    super(i), this._element = null, this._dateInput = n.createRef(), this._calendar = null, this.shouldFocusDateInput = !1, this.prevShow = !1, this.focus = () => {
      this.dateInput && this.dateInput.focus();
    }, this.setCalendarRef = (t) => {
      this._calendar = t;
    }, this.nextValue = (t, s) => t.value !== void 0 ? t.value : s.value, this.nextShow = (t, s) => t.show !== void 0 ? t.show : s.show, this.renderPopup = () => {
      const { disabled: t, min: s, max: a, weekNumber: c, focusedDate: m, popupSettings: l } = this.props, { popupClass: f, ...g } = l, v = this.show, d = this.value, w = d && W(d), u = M(
        "k-calendar-container k-group k-reset",
        f
      ), b = {
        popupClass: "k-datepicker-popup",
        show: v,
        anchor: this._element,
        className: u,
        id: this._popupId,
        anchorAlign: {
          horizontal: "left",
          vertical: "bottom"
        },
        popupAlign: {
          horizontal: "left",
          vertical: "top"
        },
        ...g
      }, h = {
        disabled: t,
        value: w,
        min: s,
        max: a,
        weekNumber: c,
        focusedDate: m,
        className: this.mobileMode ? "k-calendar-lg" : "",
        navigation: !this.mobileMode,
        onChange: this.handleCalendarValueChange
      };
      return this.mobileMode ? /* @__PURE__ */ n.createElement(this.calendarComp, { _ref: this.setCalendarRef, ...h }) : /* @__PURE__ */ n.createElement(this.popupComp, { ...b }, /* @__PURE__ */ n.createElement(this.calendarComp, { _ref: this.setCalendarRef, ...h }));
    }, this.renderAdaptivePopup = () => {
      const { windowWidth: t = 0 } = this.state, s = {
        expand: this.show,
        onClose: this.handleBlur,
        adaptiveTitle: this.props.adaptiveTitle,
        windowWidth: t
      };
      return /* @__PURE__ */ n.createElement(le, { ...s }, /* @__PURE__ */ n.createElement(re, { className: "!k-overflow-hidden" }, this.renderPopup()));
    }, this.handleInputValueChange = (t) => {
      this.handleValueChange(t.value, t);
    }, this.handleCalendarValueChange = (t) => {
      const s = this.mergeTime(t.value);
      this.handleValueChange(s, t);
    }, this.handleValueChange = (t, s) => {
      this.setState({
        value: O(t || void 0)
      }), this.valueDuringOnChange = t, this.showDuringOnChange = !1, this.mobileMode || (this.shouldFocusDateInput = !0);
      const { onChange: a } = this.props;
      a && a.call(void 0, {
        syntheticEvent: s.syntheticEvent,
        nativeEvent: s.nativeEvent,
        value: this.value,
        show: this.show,
        target: this
      }), this.valueDuringOnChange = void 0, this.showDuringOnChange = void 0, this.setShow(!1);
    }, this.handleFocus = () => {
      this.setState({ focused: !0 });
    }, this.handleBlur = () => {
      this.setState({ focused: !1 }), this.setShow(!1);
    }, this.handleIconClick = () => {
      this.props.disabled || (this.shouldFocusDateInput = !0, this.setShow(!this.show));
    }, this.handleIconMouseDown = (t) => {
      t.preventDefault();
    }, this.handleKeyDown = (t) => {
      const { altKey: s, keyCode: a } = t;
      if (a === r.esc) {
        this.shouldFocusDateInput = !0, this.setShow(!1);
        return;
      }
      s && (a === r.up || a === r.down) && (t.preventDefault(), t.stopPropagation(), this.shouldFocusDateInput = a === r.up, this.setShow(a === r.down));
    }, _(Z), this.state = {
      value: this.props.defaultValue || o.defaultProps.defaultValue,
      show: this.props.defaultShow || o.defaultProps.defaultShow,
      focused: !1
    };
  }
  get _popupId() {
    return this.props.id + "-popup-id";
  }
  get document() {
    if (P)
      return this.element && this.element.ownerDocument || document;
  }
  /**
   * Gets the wrapping element of the DatePickerWithoutContext.
   */
  get element() {
    return this._element;
  }
  /**
   * The mobile mode of the DatePicker.
   */
  get mobileMode() {
    return !!(this.state.windowWidth && this.state.windowWidth <= de && this.props.adaptive);
  }
  /**
   * Gets the DateInput component inside the DatePicker component.
   */
  get dateInput() {
    return this._dateInput.current;
  }
  /**
   * Gets the Calendar component inside the DatePicker component.
   */
  get calendar() {
    return this._calendar;
  }
  /**
   * Gets the value of the DatePickerWithoutContext.
   */
  get value() {
    const i = this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
    return i !== null ? O(i) : null;
  }
  /**
   * Gets the popup state of the DatePickerWithoutContext.
   */
  get show() {
    return this.showDuringOnChange !== void 0 ? this.showDuringOnChange : this.props.show !== void 0 ? this.props.show : this.state.show;
  }
  /**
   * Gets the `name` property of the DatePickerWithoutContext.
   */
  get name() {
    return this.props.name;
  }
  get min() {
    return this.props.min !== void 0 ? this.props.min : o.defaultProps.min;
  }
  get max() {
    return this.props.max !== void 0 ? this.props.max : o.defaultProps.max;
  }
  get dateInputComp() {
    return this.props.dateInput || o.defaultProps.dateInput;
  }
  get toggleButtonComp() {
    return this.props.toggleButton || o.defaultProps.toggleButton;
  }
  get calendarComp() {
    return this.props.calendar || o.defaultProps.calendar;
  }
  get popupComp() {
    return this.props.popup || o.defaultProps.popup;
  }
  get pickerWrapComp() {
    return this.props.pickerWrap || o.defaultProps.pickerWrap;
  }
  /**
   * Represents the validity state into which the DatePicker is set.
   */
  get validity() {
    const i = Y(this.value, this.min, this.max), t = this.props.validationMessage !== void 0, s = (!this.required || this.value !== null) && i, a = this.props.valid !== void 0 ? this.props.valid : s;
    return {
      customError: t,
      rangeOverflow: this.value && this.max.getTime() < this.value.getTime() || !1,
      rangeUnderflow: this.value && this.value.getTime() < this.min.getTime() || !1,
      valid: a,
      valueMissing: this.value === null
    };
  }
  /**
   * @hidden
   */
  get validityStyles() {
    return this.props.validityStyles !== void 0 ? this.props.validityStyles : o.defaultProps.validityStyles;
  }
  /**
   * @hidden
   */
  get required() {
    return this.props.required !== void 0 ? this.props.required : o.defaultProps.required;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var i;
    this.observerResize = P && window.ResizeObserver && new window.ResizeObserver(this.calculateMedia.bind(this)), this.show && this.forceUpdate(), (i = this.document) != null && i.body && this.observerResize && this.observerResize.observe(this.document.body);
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this._calendar && this._calendar.element && this.show && !this.prevShow && this._calendar.element.focus({ preventScroll: !0 }), this.dateInput && this.dateInput.element && !this.show && this.shouldFocusDateInput && this.dateInput.element.focus({ preventScroll: !0 }), this.prevShow = this.show, this.shouldFocusDateInput = !1;
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    var i;
    clearTimeout(this.nextTickId), (i = this.document) != null && i.body && this.observerResize && this.observerResize.disconnect();
  }
  /**
   * @hidden
   */
  render() {
    const {
      size: i = o.defaultProps.size,
      rounded: t = o.defaultProps.rounded,
      fillMode: s = o.defaultProps.fillMode,
      disabled: a,
      tabIndex: c,
      title: m,
      id: l,
      format: f,
      formatPlaceholder: g,
      min: v,
      max: d,
      className: w,
      width: u,
      name: b,
      validationMessage: h,
      required: x,
      validityStyles: B,
      ariaLabelledBy: V,
      ariaDescribedBy: z,
      ariaLabel: F,
      placeholder: N,
      label: y,
      popupSettings: pe,
      defaultValue: ce,
      defaultShow: me,
      value: fe,
      popup: ge,
      weekNumber: ve,
      dateInput: we,
      calendar: be,
      toggleButton: ye,
      onChange: Ie,
      onBlur: Ce,
      onFocus: De,
      show: ke,
      onOpen: Se,
      pickerWrap: Oe,
      ...I
    } = this.props, R = this.value, C = !this.validityStyles || this.validity.valid, A = {
      disabled: a,
      format: f,
      formatPlaceholder: g,
      id: l,
      ariaLabelledBy: V,
      ariaDescribedBy: z,
      ariaLabel: F,
      max: d,
      min: v,
      name: b,
      onChange: this.handleInputValueChange,
      required: x,
      tabIndex: this.show ? -1 : c,
      title: m,
      valid: this.validity.valid,
      validationMessage: h,
      validityStyles: B,
      value: R,
      label: void 0,
      placeholder: this.state.focused ? null : N,
      ariaExpanded: this.show,
      size: null,
      fillMode: null,
      rounded: null
    }, D = ie(this).toLanguageString(E, te[E]), k = /* @__PURE__ */ n.createElement(
      K,
      {
        onFocus: this.handleFocus,
        onBlur: this.mobileMode ? void 0 : this.handleBlur,
        onSyncBlur: this.props.onBlur,
        onSyncFocus: this.props.onFocus
      },
      (S) => /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(
        "span",
        {
          ...y ? {} : I,
          ref: (q) => {
            this._element = q;
          },
          className: M(
            "k-input",
            "k-datepicker",
            {
              [`k-input-${T.sizeMap[i] || i}`]: i,
              [`k-rounded-${T.roundedMap[t] || t}`]: t,
              [`k-input-${s}`]: s,
              "k-invalid": !C,
              "k-required": this.required,
              "k-disabled": a
            },
            w
          ),
          onKeyDown: this.handleKeyDown,
          style: { width: u },
          onFocus: S.onFocus,
          onBlur: S.onBlur,
          onClick: this.mobileMode ? this.handleIconClick : void 0
        },
        /* @__PURE__ */ n.createElement(
          this.dateInputComp,
          {
            _ref: this._dateInput,
            ariaRole: "combobox",
            readonly: this.mobileMode,
            ariaExpanded: this.show,
            ariaControls: this._popupId,
            ...A
          }
        ),
        /* @__PURE__ */ n.createElement(
          this.toggleButtonComp,
          {
            type: "button",
            icon: "calendar",
            svgIcon: X,
            title: D,
            className: "k-input-button",
            rounded: null,
            onClick: this.mobileMode ? void 0 : this.handleIconClick,
            "aria-label": D,
            onMouseDown: this.handleIconMouseDown
          }
        ),
        !this.mobileMode && this.renderPopup()
      ), this.mobileMode && this.renderAdaptivePopup())
    );
    return y ? /* @__PURE__ */ n.createElement(
      ne,
      {
        dateInput: this._dateInput,
        label: y,
        editorId: l,
        editorValid: C,
        editorDisabled: a,
        children: k,
        style: { width: u },
        ...I
      }
    ) : k;
  }
  setShow(i) {
    const { onOpen: t, onClose: s } = this.props;
    this.show !== i && (this.setState({ show: i }), i && t && t.call(void 0, {
      target: this
    }), !i && s && s.call(void 0, {
      target: this
    }));
  }
  mergeTime(i) {
    return this.value && i ? ee(i, this.value) : i;
  }
  nextTick(i) {
    clearTimeout(this.nextTickId), this.nextTickId = window.setTimeout(() => i());
  }
  calculateMedia(i) {
    for (let t of i)
      this.setState({ windowWidth: t.target.clientWidth });
  }
};
o.displayName = "DatePicker", o.propTypes = {
  className: e.string,
  defaultShow: e.bool,
  defaultValue: e.instanceOf(Date),
  disabled: e.bool,
  focusedDate: e.instanceOf(Date),
  format: e.oneOfType([
    e.string,
    e.shape({
      skeleton: e.string,
      pattern: e.string,
      date: e.oneOf(["short", "medium", "long", "full"]),
      time: e.oneOf(["short", "medium", "long", "full"]),
      datetime: e.oneOf(["short", "medium", "long", "full"]),
      era: e.oneOf(["narrow", "short", "long"]),
      year: e.oneOf(["numeric", "2-digit"]),
      month: e.oneOf(["numeric", "2-digit", "narrow", "short", "long"]),
      day: e.oneOf(["numeric", "2-digit"]),
      weekday: e.oneOf(["narrow", "short", "long"]),
      hour: e.oneOf(["numeric", "2-digit"]),
      hour12: e.bool,
      minute: e.oneOf(["numeric", "2-digit"]),
      second: e.oneOf(["numeric", "2-digit"]),
      timeZoneName: e.oneOf(["short", "long"])
    })
  ]),
  formatPlaceholder: e.oneOfType([
    e.oneOf(["wide", "narrow", "short", "formatPattern"]),
    e.shape({
      year: e.string,
      month: e.string,
      day: e.string,
      hour: e.string,
      minute: e.string,
      second: e.string
    })
  ]),
  id: e.string,
  ariaLabelledBy: e.string,
  ariaDescribedBy: e.string,
  ariaLabel: e.string,
  min: e.instanceOf(Date),
  max: e.instanceOf(Date),
  name: e.string,
  popupSettings: e.shape({
    animate: e.bool,
    appendTo: e.any,
    popupClass: e.string
  }),
  show: e.bool,
  tabIndex: e.number,
  title: e.string,
  value: e.instanceOf(Date),
  weekNumber: e.bool,
  width: e.oneOfType([e.number, e.string]),
  validationMessage: e.string,
  required: e.bool,
  validate: e.bool,
  valid: e.bool,
  size: e.oneOf([null, "small", "medium", "large"]),
  rounded: e.oneOf([null, "small", "medium", "large", "full"]),
  fillMode: e.oneOf([null, "solid", "flat", "outline"]),
  adaptive: e.bool,
  adaptiveTitle: e.string
}, o.defaultProps = {
  defaultShow: !1,
  defaultValue: null,
  dateInput: j,
  calendar: G,
  toggleButton: oe,
  popup: L,
  pickerWrap: ae,
  disabled: !1,
  format: "d",
  max: J,
  min: Q,
  popupSettings: {},
  tabIndex: 0,
  weekNumber: !1,
  required: !1,
  validityStyles: !0,
  size: "medium",
  rounded: "medium",
  fillMode: "solid"
};
let p = o;
const ue = U(), he = $(H(ue, p));
he.displayName = "KendoReactDatePicker";
se(p);
export {
  he as DatePicker,
  ue as DatePickerPropsContext,
  p as DatePickerWithoutContext
};
