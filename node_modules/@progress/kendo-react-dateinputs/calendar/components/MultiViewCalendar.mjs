/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as d from "react";
import s from "prop-types";
import { provideIntlService as q, provideLocalizationService as H, registerForIntl as j, registerForLocalization as G } from "@progress/kendo-react-intl";
import { Keys as E, classNames as X, createPropsContext as J, withIdHOC as Q, withPropsContext as Z } from "@progress/kendo-react-common";
import { isEqualDate as O, cloneDate as u, getDate as f, firstDayOfMonth as W, lastDayOfMonth as ee } from "@progress/kendo-date-math";
import { Button as T } from "@progress/kendo-react-buttons";
import { chevronRightIcon as M, chevronLeftIcon as N } from "@progress/kendo-svg-icons";
import { Action as y } from "../models/NavigationAction.mjs";
import { CalendarViewEnum as I } from "../models/CalendarViewEnum.mjs";
import { EMPTY_SELECTIONRANGE as Y } from "../models/SelectionRange.mjs";
import { Header as te } from "./Header.mjs";
import { dateInRange as R, getToday as C, viewInRange as P, nullable as D, MIN_DATE as se, MAX_DATE as ie, isInRange as A } from "../../utils.mjs";
import { prevView as S, messages as B, nextView as L } from "../../messages/index.mjs";
import { BusViewService as ae } from "../services/BusViewService.mjs";
import { NavigationService as ne } from "../services/NavigationService.mjs";
import { HorizontalViewList as x } from "./HorizontalViewList.mjs";
import { TodayCommand as le } from "./TodayCommand.mjs";
const k = (o = p.defaultProps.min, i = p.defaultProps.max, a) => a instanceof Date && !Array.isArray(a) && A(f(a), o, i) ? f(a) : null, _ = (o = p.defaultProps.min, i = p.defaultProps.max, a) => Array.isArray(a) ? a.filter((h) => A(h, o, i)).map((h) => f(h)) : null, K = (o) => typeof o == "object" && !(o instanceof Date) && o !== null && !Array.isArray(o) ? o : Y, z = (o, i, a) => o || i && i[0] || a && a.start, re = (o, i) => o.start === null && i === null ? "start" : o.end === null ? "end" : "start", c = class c extends d.Component {
  constructor(i) {
    super(i), this.dates = [], this.selectedDate = null, this.selectedMultiple = null, this.selectedRange = Y, this._focusedDate = /* @__PURE__ */ new Date(), this.cellUID = this.props.id + "-cell-uid", this.activeRangeEnd = "start", this._element = null, this.intl = null, this.localization = null, this.service = null, this.calendarViewList = null, this.isActive = !1, this.calculateFocusFromValue = !0, this.focus = () => {
      this._element && this._element.focus();
    }, this.clampRange = (e) => ({ start: e, end: null }), this.rangeWithFocused = (e, t) => ({
      start: e.start,
      end: e.end === null && e.start !== null && this.isActive ? t : e.end
    }), this.generateRange = (e, t) => {
      const { end: r, start: l } = t, m = t.start !== null && e.getTime() <= t.start.getTime();
      return !this.props.allowReverse && m ? { start: e, end: this.selectedRange.start } : this.activeRange !== "end" ? { start: e, end: r } : { start: l || this.selectedDate, end: e };
    }, this.canNavigate = (e) => {
      if (!this.service)
        return !1;
      const t = this.service.move(this.focusedDate, e);
      return this.min <= t && t <= this.max || this.service.isInSameView(t, this.min) || this.service.isInSameView(t, this.max);
    }, this.navigate = (e, t) => {
      this.calculateFocusFromValue = !1;
      const r = this.move(e, t);
      this.setState({ navigateDate: r, focusedDate: r });
    }, this.move = (e, t) => this.clampDate(this.service.move(t, e)), this.clampDate = (e) => R(e, this.min, this.max), this.shouldAutoCorrect = (e, t) => {
      const { end: r, start: l } = t;
      return this.activeRange !== "end" ? r !== null && e > r : l !== null && e < l;
    }, this.handleCellEnter = (e) => {
      this.props.mode === "range" && (this.calculateFocusFromValue = !1, this.setState({
        focusedDate: e
      }));
    }, this.handleMouseDown = (e) => {
      e.preventDefault();
    }, this.handleClick = (e) => {
      this._element && this._element.focus({ preventScroll: !0 });
    }, this.handleFocus = (e) => {
      if (this.isActive = !0, !this.calendarViewList)
        return;
      this.calendarViewList.focusActiveDate();
      const { onFocus: t } = this.props;
      t && t.call(void 0, e);
    }, this.handleBlur = (e) => {
      if (this.isActive = !1, !this.calendarViewList)
        return;
      this.calendarViewList.blurActiveDate();
      const { onBlur: t } = this.props;
      t && t.call(void 0, e);
    }, this.handleTodayClick = (e) => {
      this.todayIsInRange && this.handleDateChange(e);
    }, this.handlePrevButtonClick = () => {
      const e = y.PrevView;
      if (this.state.activeView > 0 && this.focusedDate.getFullYear() > this.dates[0].getFullYear())
        this.navigate(e, this.move(e, this.focusedDate));
      else {
        const t = this.isInMonth(this.focusedDate, this.dates[1]) ? this.move(e, this.focusedDate) : this.focusedDate;
        this.navigate(e, t);
      }
    }, this.handleNextButtonClick = () => {
      this.navigate(y.NextView, this.focusedDate);
    }, this.handleKeyDown = (e) => {
      const { keyCode: r, ctrlKey: l, metaKey: m } = e;
      if (r === 84) {
        const n = C();
        this.calculateFocusFromValue = !1, this.setState({ focusedDate: n, navigateDate: n });
      }
      if ((l || m) && (r === E.left && this.handlePrevButtonClick(), r === E.right && this.handleNextButtonClick()), r === E.enter) {
        const n = {
          syntheticEvent: e,
          nativeEvent: e.nativeEvent,
          value: this.focusedDate,
          target: this
        };
        this.handleDateChange(n);
      } else {
        const n = R(
          this.navigation.move(
            this.focusedDate,
            this.navigation.action(e),
            this.state.activeView,
            this.service,
            e
          ),
          this.min,
          this.max
        );
        if (O(this.focusedDate, n))
          return;
        this.dates && this.service && !this.service.isInArray(n, this.dates) && this.setState({ navigateDate: n }), this.calculateFocusFromValue = !1, this.setState({ focusedDate: n });
      }
      e.preventDefault();
    }, this.handleViewChange = ({ view: e }) => {
      this.calculateFocusFromValue = !1, this.setState((t) => ({ activeView: e, navigateDate: t.focusedDate }));
    }, this.handleDateChange = (e) => {
      const t = u(e.value), r = this.bus.canMoveDown(this.state.activeView);
      if (this.props.disabled)
        return;
      if (r)
        if (e.isTodayClick)
          this.bus.moveToBottom(this.state.activeView);
        else {
          this.bus.moveDown(this.state.activeView, e.syntheticEvent), this.setState({ focusedDate: t, navigateDate: t });
          return;
        }
      this.calculateFocusFromValue = !0;
      let l;
      switch (this.props.mode) {
        case "single":
          l = u(e.value);
          break;
        case "multiple":
          if (Array.isArray(this.selectedMultiple)) {
            const n = this.selectedMultiple.slice();
            let v = -1;
            n.forEach((U, $) => {
              O(U, e.value) && (v = $);
            }), v !== -1 ? n.splice(v, 1) : n.push(u(e.value)), l = n.slice();
          } else
            this.selectedDate ? l = [u(this.selectedDate), u(e.value)] : l = [u(e.value)];
          break;
        case "range": {
          l = this.selectedRange.start !== null && this.selectedRange.end !== null && this.activeRange === "start" ? this.clampRange(e.value) : this.generateRange(e.value, this.selectedRange), this.activeRangeEnd = this.activeRange !== "end" ? "end" : "start";
          break;
        }
        default:
          l = u(e.value);
          break;
      }
      this.valueDuringOnChange = l, e.isTodayClick && this.setState({ navigateDate: t }), this.setState({ value: l, focusedDate: t }), this.valueDuringOnChange = l;
      const { onChange: m } = this.props;
      if (m) {
        const n = {
          syntheticEvent: e.syntheticEvent,
          nativeEvent: e.nativeEvent,
          value: l,
          target: this
        };
        m.call(void 0, n);
      }
      this.valueDuringOnChange = void 0;
    };
    const a = i.value !== void 0 ? i.value : i.defaultValue || c.defaultProps.defaultValue, h = k(this.min, this.max, a), g = _(this.min, this.max, a), b = K(a), F = z(h, g, b), w = P(
      I[i.defaultActiveView],
      this.bottomView,
      this.topView
    ), V = R(
      i.focusedDate || F || C(),
      this.min,
      this.max
    );
    this.state = {
      value: a,
      activeView: w,
      focusedDate: V,
      navigateDate: V
    }, this.activeRangeEnd = re(b, h), this.bus = new ae(this.handleViewChange), this.navigation = new ne(this.bus), this.calculateFocusFromValue = !1, this.lastView = w, this.lastViewsCount = this.props.views || x.defaultProps.views;
  }
  get wrapperID() {
    return this.props.id + "-wrapper-id";
  }
  get isRtl() {
    return this.props.dir === "rtl";
  }
  /**
   * Gets the wrapping element of the MultiViewCalendar component.
   */
  get element() {
    return this._element;
  }
  /**
   * Gets the value of the MultiViewCalendar.
   */
  get value() {
    return this.valueDuringOnChange !== void 0 ? this.valueDuringOnChange : this.props.value !== void 0 ? this.props.value : this.state.value;
  }
  /**
   * Gets the current focused date of the MultiViewCalendar.
   */
  get focusedDate() {
    return u(this._focusedDate);
  }
  get min() {
    return f(this.props.min !== void 0 ? this.props.min : c.defaultProps.min);
  }
  get max() {
    return f(this.props.max !== void 0 ? this.props.max : c.defaultProps.max);
  }
  get bottomView() {
    return I[this.props.bottomView !== void 0 ? this.props.bottomView : c.defaultProps.bottomView];
  }
  get topView() {
    return I[this.props.topView !== void 0 ? this.props.topView : c.defaultProps.topView];
  }
  get activeRange() {
    return this.props.activeRangeEnd !== void 0 ? this.props.activeRangeEnd : this.activeRangeEnd;
  }
  get todayIsInRange() {
    return A(C(), f(this.min), f(this.max));
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.calculateFocusFromValue = !0;
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    this.calendarViewList && (this.isActive ? this.calendarViewList.focusActiveDate : this.calendarViewList.blurActiveDate)();
    const i = k(this.min, this.max, this.value);
    this.calculateFocusFromValue = !!(this.selectedDate && i && this.selectedDate.getTime() && i.getTime()), this.lastView = this.state.activeView, this.lastViewsCount = this.props.views || x.defaultProps.views;
  }
  /**
   * @hidden
   */
  render() {
    this.props._ref && this.props._ref(this), this.intl = q(this), this.localization = H(this), this.bus.configure(this.bottomView, this.topView);
    const i = P(this.state.activeView, this.bottomView, this.topView);
    this.service = this.bus.service(i, this.intl), this.selectedDate = k(this.min, this.max, this.value), this.selectedMultiple = _(this.min, this.max, this.value), this.selectedRange = K(this.value);
    const a = z(this.selectedDate, this.selectedMultiple, this.selectedRange);
    this._focusedDate = R(
      this.calculateFocusFromValue && a !== null ? a : this.state.focusedDate,
      this.min,
      this.max
    );
    const h = X(
      "k-widget k-calendar k-calendar-range",
      {
        "k-disabled": this.props.disabled
      },
      this.props.className
    ), g = this.rangeWithFocused(this.selectedRange, this.focusedDate), b = this.localization.toLanguageString(S, B[S]), F = this.localization.toLanguageString(L, B[L]), w = !this.canNavigate(y.PrevView), V = !this.canNavigate(y.NextView), e = { "aria-disabled": w }, t = { "aria-disabled": V }, r = this.lastView !== i, l = this.dates && this.isInMonth(this.state.navigateDate, this.dates[0]), m = this.lastViewsCount !== this.props.views;
    (!l || r || m) && (this.dates = this.service.datesList(
      this.state.navigateDate,
      this.props.views || x.defaultProps.views
    ));
    const n = u(this.dates && this.dates[0] ? this.dates[0] : C());
    return /* @__PURE__ */ d.createElement(
      "div",
      {
        ref: (v) => {
          this._element = v;
        },
        className: h,
        id: this.props.id || this.wrapperID,
        "aria-labelledby": this.props.ariaLabelledBy,
        "aria-describedby": this.props.ariaDescribedBy,
        tabIndex: this.props.disabled ? void 0 : this.props.tabIndex,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur,
        onMouseDown: this.handleMouseDown,
        onClick: this.handleClick,
        onKeyDown: this.handleKeyDown,
        "aria-disabled": this.props.disabled,
        dir: this.props.dir
      },
      /* @__PURE__ */ d.createElement(
        te,
        {
          key: `.kendo.calendar.header.${n.getTime()}`,
          activeView: i,
          currentDate: n,
          min: this.min,
          max: this.max,
          rangeLength: this.props.views,
          bus: this.bus,
          service: this.service,
          headerTitle: this.props.headerTitle,
          verticalView: this.props.mobileMode,
          commands: /* @__PURE__ */ d.createElement(d.Fragment, null, /* @__PURE__ */ d.createElement(
            T,
            {
              type: "button",
              className: "k-calendar-nav-prev",
              icon: this.isRtl ? "chevron-right" : "chevron-left",
              svgIcon: this.isRtl ? M : N,
              fillMode: "flat",
              title: b,
              disabled: w,
              onClick: this.handlePrevButtonClick,
              ...e
            }
          ), /* @__PURE__ */ d.createElement(
            le,
            {
              min: this.min,
              max: this.max,
              onClick: this.handleTodayClick,
              disabled: !this.todayIsInRange
            }
          ), /* @__PURE__ */ d.createElement(
            T,
            {
              type: "button",
              className: "k-calendar-nav-next",
              icon: this.isRtl ? "chevron-left" : "chevron-right",
              svgIcon: this.isRtl ? N : M,
              fillMode: "flat",
              title: F,
              disabled: V,
              onClick: this.handleNextButtonClick,
              ...t
            }
          ))
        }
      ),
      /* @__PURE__ */ d.createElement(
        x,
        {
          ref: (v) => {
            this.calendarViewList = v;
          },
          dates: this.dates,
          activeView: i,
          focusedDate: this.focusedDate,
          min: this.min,
          max: this.max,
          bus: this.bus,
          service: this.service,
          selectionRange: g,
          value: this.selectedMultiple || this.selectedDate,
          cellUID: this.cellUID,
          views: this.props.views,
          onChange: this.handleDateChange,
          showWeekNumbers: this.props.weekNumber,
          onCellEnter: this.handleCellEnter,
          cell: this.props.cell,
          weekCell: this.props.weekCell,
          headerTitle: this.props.headerTitle,
          verticalView: this.props.mobileMode
        }
      )
    );
  }
  // protected isListInRange = (list: Date[]): boolean => {
  //     return this.min < list[0]
  //         && this.max > list[Math.max(0, (this.props.views || MultiViewCalendarWithoutContext.defaultProps.views) - 1)];
  // };
  isInMonth(i, a) {
    return !!a && W(a) <= i && i <= ee(a);
  }
};
c.displayName = "MultiViewCalendar", c.propTypes = {
  activeRangeEnd: s.oneOf(["start", "end"]),
  allowReverse: s.bool,
  bottomView: s.oneOf(["month", "year", "decade", "century"]),
  className: s.string,
  defaultActiveView: s.oneOf(["month", "year", "decade", "century"]),
  defaultValue: s.oneOfType([
    D(s.instanceOf(Date)),
    s.arrayOf(s.instanceOf(Date)),
    s.shape({
      start: D(s.instanceOf(Date)),
      end: D(s.instanceOf(Date))
    })
  ]),
  disabled: s.bool,
  focusedDate: s.instanceOf(Date),
  id: s.string,
  ariaLabelledBy: s.string,
  ariaDescribedBy: s.string,
  max: s.instanceOf(Date),
  min: s.instanceOf(Date),
  mode: s.oneOf(["single", "multiple", "range"]),
  onBlur: s.func,
  onChange: s.func,
  onFocus: s.func,
  tabIndex: s.number,
  topView: s.oneOf(["month", "year", "decade", "century"]),
  value: s.oneOfType([
    D(s.instanceOf(Date)),
    s.arrayOf(s.instanceOf(Date)),
    s.shape({
      start: D(s.instanceOf(Date).isRequired),
      end: D(s.instanceOf(Date).isRequired)
    })
  ]),
  views: (i, a, h) => {
    const g = i[a];
    return g !== void 0 && g < 1 ? new Error(
      `Invalid prop '${a}' supplied to'${h}'. The '${a}' property cannot be less than 1'`
    ) : null;
  },
  weekNumber: s.bool,
  dir: s.string
}, c.defaultProps = {
  disabled: !1,
  min: se,
  max: ie,
  navigation: !0,
  defaultActiveView: "month",
  defaultValue: null,
  topView: "century",
  tabIndex: 0,
  bottomView: "month",
  views: 2,
  allowReverse: !1
};
let p = c;
const oe = J(), he = Q(Z(oe, p));
he.displayName = "KendoReactMultiViewCalendar";
j(p);
G(p);
export {
  he as MultiViewCalendar,
  oe as MultiViewCalendarPropsContext,
  p as MultiViewCalendarWithoutContext
};
