/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as s from "react";
import { getActiveElement as d, IconWrap as a, classNames as r } from "@progress/kendo-react-common";
import { Popup as u } from "@progress/kendo-react-popup";
import { shouldOpenItem as l, isFirstItemFromSiblings as h } from "../utils/itemsIdsUtils.mjs";
import { getDOMElementId as n, convertBoolDirectionToString as p, getPopupSettings as c } from "../utils/misc.mjs";
import { MenuItemLink as I } from "./MenuItemLink.mjs";
import { MenuItemArrow as M } from "./MenuItemArrow.mjs";
class g extends s.Component {
  constructor() {
    super(...arguments), this.onMouseOver = (e) => {
      this.props.onMouseOver(this.props.parentItemId), e.stopPropagation();
    }, this.onMouseLeave = (e) => {
      this.props.onMouseLeave(this.props.parentItemId), e.stopPropagation();
    };
  }
  render() {
    const e = this.props.parentItemId;
    return /* @__PURE__ */ s.createElement(
      "ul",
      {
        className: this.props.className,
        role: this.props.role ? this.props.role : e !== void 0 ? "menu" : "menubar",
        id: e !== void 0 ? n(this.props.menuGuid, e) : void 0,
        onMouseOver: e !== void 0 ? this.onMouseOver : void 0,
        onMouseLeave: e !== void 0 ? this.onMouseLeave : void 0,
        "aria-orientation": this.props["aria-orientation"]
      },
      this.renderChildItems()
    );
  }
  renderChildItems() {
    return this.props.items.length > 0 ? this.props.items.map((e, t) => /* @__PURE__ */ s.createElement(
      f,
      {
        item: e,
        isMenuVertical: this.props.isMenuVertical,
        isDirectionRightToLeft: this.props.isDirectionRightToLeft,
        focusedItemId: this.props.focusedItemId,
        lastItemIdToBeOpened: this.props.lastItemIdToBeOpened,
        tabbableItemId: this.props.tabbableItemId,
        itemRender: this.props.itemRender,
        linkRender: this.props.linkRender,
        menuGuid: this.props.menuGuid,
        onMouseOver: this.props.onMouseOver,
        onMouseLeave: this.props.onMouseLeave,
        onMouseDown: this.props.onMouseDown,
        onBlur: this.props.onBlur,
        onFocus: this.props.onFocus,
        onClick: this.props.onClick,
        onOriginalItemNeeded: this.props.onOriginalItemNeeded,
        key: t
      }
    )) : null;
  }
}
class f extends s.Component {
  constructor(e) {
    super(e), this.isFirstRender = !0, this.onMouseOver = (t) => {
      this.props.onMouseOver(this.props.item.id), t.stopPropagation();
    }, this.onMouseLeave = (t) => {
      this.props.onMouseLeave(this.props.item.id), t.stopPropagation();
    }, this.state = { opened: !1 };
  }
  componentDidMount() {
    const e = this.props.focusedItemId, t = this.props.item.id;
    e && e === t && this.itemElement.focus(), this.isFirstRender = !1;
  }
  componentDidUpdate(e) {
    const t = this.props.focusedItemId, o = this.props.item.id;
    if (t) {
      const i = d(document);
      e.focusedItemId !== t && t === o && !this.itemElement.contains(i) && this.itemElement.focus();
    }
  }
  render() {
    const e = this.props.item, t = e.id, o = n(this.props.menuGuid, t);
    return /* @__PURE__ */ s.createElement(s.Fragment, null, /* @__PURE__ */ s.createElement(
      "li",
      {
        id: n(this.props.menuGuid, t),
        className: this.getMenuItemClassName(e),
        style: e.cssStyle,
        tabIndex: t === this.props.tabbableItemId ? 0 : -1,
        onMouseOver: this.onMouseOver,
        onMouseLeave: this.onMouseLeave,
        onMouseDown: (i) => this.props.onMouseDown(i),
        onBlur: (i) => this.props.onBlur(t, i),
        onFocus: () => this.props.onFocus(t),
        onClick: (i) => this.props.onClick(i, t),
        role: "menuitem",
        "aria-disabled": e.disabled ? !0 : void 0,
        "aria-haspopup": e.items.length > 0 ? !0 : void 0,
        "aria-expanded": e.items.length > 0 ? this.Opened : void 0,
        "aria-label": e.text,
        "aria-owns": this.Opened ? o : void 0,
        ref: (i) => this.itemElement = i,
        key: "0"
      },
      this.contentRender ? this.renderContent() : this.renderMenuItemLink()
    ), this.renderPopupIfOpened());
  }
  renderContent() {
    const e = this.props.item.contentParentItemId;
    return /* @__PURE__ */ s.createElement("div", { className: "k-content", role: "presentation" }, /* @__PURE__ */ s.createElement(this.contentRender, { item: this.props.onOriginalItemNeeded(e), itemId: e }));
  }
  renderMenuItemLink() {
    const e = this.props.item;
    if (this.linkRender)
      return /* @__PURE__ */ s.createElement(
        this.linkRender,
        {
          item: this.props.onOriginalItemNeeded(e.id),
          itemId: e.id,
          opened: this.Opened,
          dir: p(this.props.isDirectionRightToLeft)
        }
      );
    {
      const t = this.itemRender ? /* @__PURE__ */ s.createElement(this.itemRender, { item: this.props.onOriginalItemNeeded(e.id), itemId: e.id, key: "1" }) : /* @__PURE__ */ s.createElement("span", { className: "k-menu-link-text" }, e.text);
      return /* @__PURE__ */ s.createElement(I, { url: e.url, opened: this.Opened }, this.renderMenuIconIfApplicable(), t, this.renderArrowIfApplicable());
    }
  }
  renderPopupIfOpened() {
    if (this.Opened) {
      const e = this.props.item.id, { anchorAlign: t, popupAlign: o, collision: i } = c(e, this.props.isMenuVertical, this.props.isDirectionRightToLeft);
      return /* @__PURE__ */ s.createElement(
        u,
        {
          anchor: this.itemElement,
          show: !0,
          popupClass: this.getPopupClassName(),
          anchorAlign: t,
          popupAlign: o,
          collision: i,
          animate: !1,
          key: "1"
        },
        /* @__PURE__ */ s.createElement(
          g,
          {
            parentItemId: e,
            items: this.props.item.items,
            menuGuid: this.props.menuGuid,
            focusedItemId: this.props.focusedItemId,
            lastItemIdToBeOpened: this.props.lastItemIdToBeOpened,
            tabbableItemId: this.props.tabbableItemId,
            itemRender: this.props.itemRender,
            linkRender: this.props.linkRender,
            isMenuVertical: this.props.isMenuVertical,
            isDirectionRightToLeft: this.props.isDirectionRightToLeft,
            className: "k-group k-menu-group k-reset k-menu-group-md",
            onMouseOver: this.props.onMouseOver,
            onMouseLeave: this.props.onMouseLeave,
            onMouseDown: this.props.onMouseDown,
            onBlur: this.props.onBlur,
            onFocus: this.props.onFocus,
            onClick: this.props.onClick,
            onOriginalItemNeeded: this.props.onOriginalItemNeeded
          }
        )
      );
    } else
      return null;
  }
  renderMenuIconIfApplicable() {
    const { icon: e, svgIcon: t } = this.props.item;
    return e || t ? /* @__PURE__ */ s.createElement(a, { name: e, icon: t, key: "0" }) : null;
  }
  renderArrowIfApplicable() {
    return this.props.item.items.length > 0 ? /* @__PURE__ */ s.createElement("span", { className: "k-menu-expand-arrow", "aria-hidden": !0 }, /* @__PURE__ */ s.createElement(
      M,
      {
        itemId: this.props.item.id,
        verticalMenu: this.props.isMenuVertical,
        dir: p(this.props.isDirectionRightToLeft),
        key: "2"
      }
    )) : null;
  }
  get itemRender() {
    return this.props.item.render || this.props.itemRender;
  }
  get linkRender() {
    return this.props.item.linkRender || this.props.linkRender;
  }
  get contentRender() {
    return this.props.item.contentParentItemId ? this.props.item.contentRender : null;
  }
  get Opened() {
    const e = this.props;
    return e.item.items.length > 0 && l(e.item.id, e.lastItemIdToBeOpened) && // HACK: Wait for the second render because otherwise the scenario of
    // popup inside popup throws an error (for example, hover of item with id '0_0').
    !this.isFirstRender;
  }
  getPopupClassName() {
    return r("k-menu-popup", { "k-rtl": this.props.isDirectionRightToLeft });
  }
  getMenuItemClassName(e) {
    return r(
      "k-item",
      "k-menu-item",
      {
        "k-first": h(e.id),
        "k-last": e.isLastFromSiblings,
        "k-disabled": e.disabled
      },
      e.cssClass
    );
  }
}
export {
  f as MenuItemInternal,
  g as MenuItemInternalsList
};
