/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import h from "prop-types";
import { TabStripNavigationItem as g } from "./TabStripNavigationItem.mjs";
import { classNames as I } from "@progress/kendo-react-common";
import { Button as x } from "@progress/kendo-react-buttons";
import { caretAltRightIcon as P, caretAltLeftIcon as k, caretAltUpIcon as A, caretAltDownIcon as M } from "@progress/kendo-svg-icons";
const E = (w) => Array.apply(null, Array(w)), L = (w) => w.preventDefault(), b = "smooth", d = "prev", u = "next", T = class T extends a.Component {
  constructor(l) {
    super(l), this.itemsNavRef = a.createRef(), this.isRtl = () => this.props.dir === "rtl", this.onWheel = (t) => {
      t.stopPropagation();
      const s = t.deltaY < 0 ? d : u;
      this.setNewScrollPosition(s, t);
    }, this.arrowClickPrev = (t) => {
      this.handleArrowClick(d, t);
    }, this.arrowClickNext = (t) => {
      this.handleArrowClick(u, t);
    }, this.handleArrowClick = (t, s) => {
      this.setNewScrollPosition(t, s);
    }, this.setNewScrollPosition = (t, s) => {
      const e = this.itemsNavRef.current;
      if (!e)
        return;
      const n = this.horizontalScroll(), c = n ? e.scrollWidth - e.offsetWidth : e.scrollHeight - e.offsetHeight, r = (s.type === "click" ? this.props.buttonScrollSpeed : this.props.mouseScrollSpeed) || 0;
      let o = n ? e.scrollLeft : e.scrollTop, i = n ? e.scrollWidth - e.scrollLeft : e.scrollHeight - e.scrollTop, f = e.scrollWidth - e.scrollLeft * -1;
      this.isRtl() && this.horizontalScroll() ? (t === d && o < 0 && (o += r, f += r), t === u && o < c && (o -= r, f -= r), o = Math.min(0, Math.min(c, o))) : (t === d && o > 0 && (o -= r, i += r), t === u && o < c && (o += r, i -= r), o = Math.max(0, Math.min(c, o)));
      const m = o === 0, v = s.type === "click" ? b : void 0;
      if (n) {
        const S = this.isRtl() ? Math.round(f) <= e.clientWidth || Math.floor(f) <= e.clientWidth : Math.round(i) <= e.clientWidth || Math.floor(i) <= e.clientWidth;
        this.setState({
          disabledPrev: m,
          disabledNext: S
        }), e.scrollTo({ left: o, behavior: v });
      } else
        this.setState({
          disabledPrev: m,
          disabledNext: Math.round(i) <= e.clientHeight || Math.floor(i) <= e.clientHeight
        }), e.scrollTo({ top: o, behavior: v });
    }, this.renderArrow = (t, s) => {
      const e = this.horizontalScroll(), n = {
        prev: {
          arrowTab: "k-tabstrip-prev",
          fontIcon: e ? this.isRtl() ? "caret-alt-right" : "caret-alt-left" : "caret-alt-up",
          svgIcon: e ? this.isRtl() ? P : k : A
        },
        next: {
          arrowTab: "k-tabstrip-next",
          fontIcon: e ? this.isRtl() ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down",
          svgIcon: e ? this.isRtl() ? k : P : M
        }
      }, c = (t === d ? this.props.prevButton : this.props.nextButton) || x, r = t === d ? this.arrowClickPrev : this.arrowClickNext;
      return /* @__PURE__ */ a.createElement(
        c,
        {
          disabled: s,
          className: `${n[t].arrowTab}`,
          onClick: r,
          icon: n[t].fontIcon,
          svgIcon: n[t].svgIcon,
          onMouseDown: L,
          tabIndex: -1,
          fillMode: "flat"
        }
      );
    }, this.state = {
      disabledPrev: this.props.selected === 0,
      disabledNext: this.props.selected === a.Children.count(this.props.children) - 1
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    this.props.scrollable && this.scrollToSelected();
  }
  /**
   * @hidden
   */
  componentDidUpdate(l) {
    const { scrollable: t, selected: s } = this.props;
    t && l.selected !== s && (this.scrollToSelected(), this.setState({
      disabledPrev: s === 0,
      disabledNext: s === a.Children.count(this.props.children) - 1
    }));
  }
  /**
   * @hidden
   */
  render() {
    const { selected: l, tabPosition: t, children: s, onSelect: e, onKeyDown: n, navItemId: c, contentPanelId: r, renderAllContent: o } = this.props, i = a.Children.count(s), f = a.Children.toArray(s);
    let m;
    s && (m = E(i).map((W, p, C) => {
      const R = {
        active: l === p,
        disabled: f[p].props.disabled,
        index: p,
        title: f[p].props.title,
        first: p === 0,
        last: p === C.length - 1,
        contentPanelId: r,
        renderAllContent: o,
        id: c,
        onSelect: e
      };
      return /* @__PURE__ */ a.createElement(g, { key: p, ...R });
    }));
    const v = I("k-tabstrip-items-wrapper", {
      "k-hstack": t === "top" || t === "bottom",
      "k-vstack": t === "left" || t === "right"
    }), S = I("k-tabstrip-items", "k-reset");
    return /* @__PURE__ */ a.createElement("div", { className: v }, this.props.scrollable ? /* @__PURE__ */ a.createElement(a.Fragment, null, this.renderArrow(d, this.state.disabledPrev), /* @__PURE__ */ a.createElement(
      "ul",
      {
        ref: this.itemsNavRef,
        className: S,
        role: "tablist",
        tabIndex: this.props.tabIndex,
        onKeyDown: n,
        onWheel: this.onWheel,
        "aria-orientation": t === "left" || t === "right" ? "vertical" : void 0
      },
      m
    ), this.renderArrow(u, this.state.disabledNext)) : /* @__PURE__ */ a.createElement(
      "ul",
      {
        className: S,
        role: "tablist",
        tabIndex: this.props.tabIndex,
        onKeyDown: n
      },
      m
    ));
  }
  scrollToSelected() {
    const l = this.itemsNavRef.current, t = l && l.children[this.props.selected || 0];
    if (t instanceof HTMLElement && l instanceof HTMLElement) {
      const s = this.horizontalScroll(), e = s ? l.offsetWidth : l.offsetHeight, n = s ? t.offsetWidth : t.offsetHeight, c = s ? "left" : "top";
      let r = s ? l.scrollLeft : l.scrollTop, o = 0;
      if (this.isRtl()) {
        const i = t.offsetLeft;
        r = r * -1, i < 0 ? (o = i - n + l.offsetLeft, l.scrollTo({ [c]: o, behavior: b })) : i + n > e - r && (o = r + i - n, l.scrollTo({ [c]: o, behavior: b }));
      } else {
        const i = s ? t.offsetLeft - l.offsetLeft : t.offsetTop - l.offsetTop;
        r + e < i + n ? (o = i + n - e, l.scrollTo({ [c]: o, behavior: b })) : r > i && (o = i, l.scrollTo({ [c]: o, behavior: b }));
      }
    }
  }
  horizontalScroll() {
    return /top|bottom/.test(this.props.tabPosition || "top");
  }
};
T.propTypes = {
  children: h.oneOfType([
    h.element,
    h.arrayOf(h.element)
  ]),
  onSelect: h.func,
  onKeyDown: h.func,
  selected: h.number,
  tabIndex: h.number
};
let N = T;
export {
  N as TabStripNavigation
};
