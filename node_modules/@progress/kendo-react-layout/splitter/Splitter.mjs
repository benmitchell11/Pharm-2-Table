/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as S from "react";
import { SplitterPane as T } from "./SplitterPane.mjs";
import { SplitterBar as b } from "./SplitterBar.mjs";
import { validatePackage as w, classNames as B } from "@progress/kendo-react-common";
import { packageMetadata as N } from "../package-metadata.mjs";
import { splitBarLabel as O, messages as R } from "./messages/index.mjs";
import { provideLocalizationService as _ } from "@progress/kendo-react-intl";
const k = {
  collapsible: !1,
  collapsed: !1,
  resizable: !0,
  scrollable: !0
}, K = 150, D = class D extends S.Component {
  /**
   * @hidden
   */
  constructor(s) {
    super(s), this._container = null, this.validatePanes = (t) => {
      if (!t.filter((i) => i.size === void 0).length)
        throw new Error("The Splitter should have at least one pane without a set size.");
    }, this.mapPaneOptions = (t, e) => {
      const i = this.orientation, { dragIndex: r, isDragging: a } = this.state, l = [];
      for (let n = 0; n < e.length; n++) {
        let o = !1;
        const p = e[n];
        S.isValidElement(p) && (o = p.type.displayName === "Splitter");
        let h = !1;
        a && r !== void 0 && (h = r === n || r + 1 === n), l.push({
          ...k,
          orientation: i,
          containsSplitter: o,
          overlay: h,
          ...(t || [])[n]
        });
      }
      return l;
    }, this.mapSplitterPanes = (t, e) => {
      const i = _(this).toLanguageString(O, R[O]);
      return t.map((r, a) => {
        let l;
        const n = a * 2, o = n + 1;
        if (a + 1 < t.length) {
          const h = t[a + 1];
          l = /* @__PURE__ */ S.createElement(
            b,
            {
              key: o,
              index: a,
              orientation: r.orientation,
              prev: r,
              next: h,
              ariaLabel: i,
              onDrag: this.onBarDragResize,
              onToggle: this.onBarToggle,
              onKeyboardResize: this.onBarKeyboardResize,
              isRtl: this.isRtl
            }
          );
        }
        return [/* @__PURE__ */ S.createElement(
          T,
          {
            key: n,
            ...r
          },
          e[a]
        ), l];
      });
    }, this.onBarToggle = (t, e) => {
      const r = this.panesOptions(this.panesContent).map((a, l) => {
        const n = this.getPaneProps(a);
        return l === t ? {
          ...n,
          collapsed: !a.collapsed
        } : {
          ...n
        };
      });
      this.props.onChange && this.props.onChange({
        newState: r,
        isLast: !0,
        nativeEvent: e
      });
    }, this.onBarDragResize = (t, e, i, r, a) => {
      const l = (/* @__PURE__ */ new Date()).getTime(), { pageX: n, pageY: o } = t, { prevElement: p, nextElement: h } = this.surroudingPanes(e);
      if (!p || !h)
        return;
      if (r) {
        this.setState({
          isDragging: !0,
          dragIndex: i,
          startTime: l,
          originalX: n,
          originalY: o,
          originalPrevSize: this.elementSize(p),
          originalNextSize: this.elementSize(h)
        });
        return;
      }
      const { originalPrevSize: d, originalNextSize: g, startTime: P, originalX: f, originalY: u } = this.state;
      if (!r && l - P < K) {
        a && this.resetDragState();
        return;
      }
      let c;
      this.orientation === "vertical" ? c = o - u : this.isRtl ? c = f - n : c = n - f, this.resize(i, i + 1, d, g, c, a, t), a && this.resetDragState();
    }, this.onBarKeyboardResize = (t, e, i, r) => {
      const { prevElement: a, nextElement: l } = this.surroudingPanes(t), n = this.elementSize(a), o = this.elementSize(l);
      this.resize(e, e + 1, n, o, i, !0, r);
    }, this.containerSize = () => this._container ? this.elementSize(this._container, !0) : 0, this.panesOptions = (t) => this.mapPaneOptions(this.panes, t), this.elementSize = (t, e) => {
      const i = e ? "client" : "offset";
      return this.orientation === "vertical" ? t[`${i}Height`] : t[`${i}Width`];
    }, this.clamp = (t, e, i) => Math.min(e, Math.max(t, i)), this.fixedSize = (t) => t && t.length > 0, w(N), this.state = {
      isDragging: !1,
      dragIndex: void 0,
      startTime: 0,
      originalX: 0,
      originalY: 0,
      originalPrevSize: 0,
      originalNextSize: 0,
      panes: s.defaultPanes || []
    };
  }
  get isControlledState() {
    return this.props.panes !== void 0;
  }
  get panes() {
    return this.panesDuringOnChange !== void 0 ? this.panesDuringOnChange : this.isControlledState ? this.props.panes : this.state.panes;
  }
  get orientation() {
    return this.props.orientation || "horizontal";
  }
  get isRtl() {
    return this._container && getComputedStyle(this._container).direction === "rtl" || !1;
  }
  get panesContent() {
    return S.Children.toArray(this.props.children).filter((s) => s);
  }
  /**
   * @hidden
   */
  render() {
    const s = this.panesContent, t = this.panesOptions(s), e = B(
      "k-widget",
      "k-splitter",
      "k-splitter-flex",
      `k-splitter-${this.orientation}`,
      this.props.className
    );
    return this.validatePanes(t), /* @__PURE__ */ S.createElement(
      "div",
      {
        style: this.props.style,
        ref: (i) => this._container = i,
        className: e
      },
      this.mapSplitterPanes(t, s)
    );
  }
  surroudingPanes(s) {
    return {
      prevElement: s.previousElementSibling,
      nextElement: s.nextElementSibling
    };
  }
  isPercent(s) {
    return /%$/.test(s);
  }
  toPixels(s, t) {
    let e = parseInt(s, 10);
    return this.isPercent(s) && (e = t * e / 100), e;
  }
  resetDragState() {
    this.setState({
      isDragging: !1,
      dragIndex: void 0,
      startTime: 0,
      originalX: 0,
      originalY: 0,
      originalPrevSize: 0,
      originalNextSize: 0
    });
  }
  resize(s, t, e, i, r, a, l) {
    const n = this.panesOptions(this.panesContent), o = n[s], p = n[t], h = e + i, d = this.containerSize(), g = (m) => this.toPixels(m, d), P = {
      index: s,
      initialSize: e,
      min: g(o.min) || h - g(p.max) || 0,
      max: g(o.max) || h - g(p.min) || h
    }, f = {
      index: t,
      initialSize: i,
      min: g(p.min) || h - g(o.max) || 0,
      max: g(p.max) || h - g(o.min) || h
    }, u = (m, v) => {
      const z = n[m.index], E = this.clamp(m.min, m.max, m.initialSize + v);
      return this.isPercent(z.size || "") ? 100 * E / d + "%" : E + "px";
    };
    let c, x;
    this.fixedSize(o.size) && this.fixedSize(p.size) ? (c = u(P, r), x = u(f, -r)) : p.collapsible || this.fixedSize(p.size) ? x = u(f, -r) : c = u(P, r);
    const C = n.map((m, v) => {
      const z = this.getPaneProps(m);
      return v === s ? {
        ...z,
        size: c
      } : v === t ? {
        ...z,
        size: x
      } : {
        ...z
      };
    });
    this.panesDuringOnChange = C, this.isControlledState || this.setState({
      panes: C
    }), this.props.onChange && this.props.onChange({
      newState: C,
      isLast: a,
      nativeEvent: l
    }), this.panesDuringOnChange = void 0;
  }
  getPaneProps(s) {
    const { orientation: t, overlay: e, containsSplitter: i, ...r } = s;
    return r;
  }
};
D.displayName = "Splitter";
let y = D;
export {
  y as Splitter
};
