/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as n from "react";
import t from "prop-types";
import { dispatchEvent as b, validatePackage as k, shouldShowValidationUI as S, classNames as N, getter as E, WatermarkOverlay as v } from "@progress/kendo-react-common";
import { InternalTile as x } from "./InternalTile.mjs";
import { packageMetadata as y } from "../package-metadata.mjs";
const O = {
  column: "k-grid-flow-col",
  row: "k-grid-flow-row",
  "column dense": "k-grid-flow-col-dense",
  "row dense": "k-grid-flow-row-dense",
  unset: "k-grid-flow-unset"
}, h = class h extends n.Component {
  constructor(a) {
    super(a), this._element = null, this.state = { positions: (this.props.items || []).map((i, o) => Object.assign({ order: o, rowSpan: 1, colSpan: 1 }, i.defaultPosition)) }, this.showLicenseWatermark = !1, this.focus = () => {
      this._element && this._element.focus();
    }, this.update = (i, o, s, l = 0, u = 0) => {
      if (o === 0 && s === 0 && !u && !l)
        return;
      let m = !1;
      const c = this.state.positions.map((f) => Object.assign({}, f)), r = c[i], d = c.find((f) => f.order === r.order + o);
      d && d !== r && (r.order += o, d.order += -o, m = !0);
      const e = r.col + s;
      s !== 0 && e >= 1 && e + r.colSpan <= (this.props.columns || 3) + 1 && (r.col = e, m = !0);
      const p = r.colSpan + u;
      u && p >= 1 && p + r.col <= (this.props.columns || 3) + 1 && (r.colSpan = p, m = !0);
      const g = r.rowSpan + l;
      l && g >= 1 && (r.rowSpan = g, m = !0), m && (this.setState({ positions: c }), b(this.props.onReposition, {}, this, { value: c }));
    }, k(y), this.showLicenseWatermark = S(y);
  }
  /**
   * Gets the HTML element of the TileLayout component.
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(a, i) {
    return a.positions ? {
      positions: a.positions.map((o, s) => Object.assign({ order: s, rowSpan: 1, colSpan: 1 }, o))
    } : a.items && (!i.positions || a.items.length !== i.positions.length) ? {
      positions: a.items.map((o, s) => Object.assign({ order: s, rowSpan: 1, colSpan: 1 }, o.defaultPosition))
    } : null;
  }
  render() {
    const {
      className: a,
      columns: i = 3,
      columnWidth: o = "1fr",
      gap: s,
      rowHeight: l = "1fr",
      style: u,
      autoFlow: m = "column",
      items: c = []
    } = this.props, r = s ? `${typeof s.rows == "number" ? s.rows + "px" : s.rows} ${typeof s.columns == "number" ? s.columns + "px" : s.columns}` : 16, d = {
      gridTemplateColumns: `repeat(${i}, minmax(0px, ${typeof o == "number" ? o + "px" : o}))`,
      gridAutoRows: `minmax(0px, ${typeof l == "number" ? l + "px" : l})`,
      gap: r,
      padding: r,
      ...u
    };
    return /* @__PURE__ */ n.createElement(
      "div",
      {
        ref: (e) => {
          this._element = e;
        },
        dir: this.props.dir,
        className: N("k-tilelayout k-pos-relative", O[m], a),
        style: d,
        id: this.props.id,
        children: c.map(
          (e, p) => /* @__PURE__ */ n.createElement(n.Fragment, { key: this.props.dataItemKey ? E(this.props.dataItemKey)(e) : p }, /* @__PURE__ */ n.createElement(
            x,
            {
              update: this.update,
              defaultPosition: this.state.positions[p],
              index: p,
              resizable: e.resizable,
              reorderable: e.reorderable,
              style: e.style,
              className: e.className,
              hintClassName: e.hintClassName,
              hintStyle: e.hintStyle,
              ignoreDrag: this.props.ignoreDrag
            },
            e.item ? e.item : /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("div", { className: "k-tilelayout-item-header k-card-header" }, n.isValidElement(e.header) ? e.header : /* @__PURE__ */ n.createElement("h5", { className: "k-card-title" }, e.header)), /* @__PURE__ */ n.createElement("div", { className: "k-tilelayout-item-body k-card-body" }, e.body))
          ), this.showLicenseWatermark && /* @__PURE__ */ n.createElement(v, null))
        )
      }
    );
  }
};
h.propTypes = {
  id: t.string,
  style: t.object,
  className: t.string,
  dir: t.string,
  gap: t.object,
  columns: t.number,
  columnWidth: t.oneOfType([t.number, t.string]),
  rowHeight: t.oneOfType([t.number, t.string]),
  dataItemKey: t.string,
  items: t.array,
  positions: t.array,
  autoFlow: t.oneOf(["column", "row", "column dense", "row dense", "unset"]),
  onReposition: t.func,
  ignoreDrag: t.func
}, h.displayName = "KendoTileLayout";
let w = h;
export {
  w as TileLayout
};
