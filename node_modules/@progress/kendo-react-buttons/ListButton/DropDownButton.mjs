/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as p from "react";
import s from "prop-types";
import { Button as v } from "../Button.mjs";
import { Keys as r, dispatchEvent as h, getActiveElement as l, validatePackage as K, svgIconPropType as P, classNames as c, kendoThemeMaps as M } from "@progress/kendo-react-common";
import { navigate as A } from "./utils/navigation.mjs";
import { DropDownButtonItem as R } from "./DropDownButtonItem.mjs";
import { ButtonItem as z } from "./ButtonItem.mjs";
import { Popup as N } from "@progress/kendo-react-popup";
import { getAnchorAlign as T, getPopupAlign as $ } from "./utils/popup.mjs";
import { packageMetadata as U } from "../package-metadata.mjs";
const u = class u extends p.Component {
  constructor(i) {
    super(i), this.state = {
      opened: !1,
      focused: !1,
      focusedIndex: -1
    }, this.mainButton = null, this.list = null, this.skipFocus = !1, this.buttonsData = [], this.onKeyDown = (t) => {
      const { focusedIndex: e } = this.state;
      if (t.altKey) {
        !this.opened && t.keyCode === r.down ? (t.preventDefault(), this.setOpen(!0, t), this.setState({ focusedIndex: 0 })) : this.opened && t.keyCode === r.up && (t.preventDefault(), this.setState({ focusedIndex: -1 }), this.setOpen(!1, t));
        return;
      }
      const o = { ...this.state };
      if (t.keyCode === r.enter || t.keyCode === r.space) {
        t.preventDefault(), e >= 0 && this.dispatchClickEvent(t, e);
        const n = !this.opened;
        this.setState({
          focused: !0,
          focusedIndex: n ? 0 : -1
        }), this.setOpen(n, t);
        return;
      }
      if (this.opened && t.keyCode === r.esc) {
        this.setState({ focusedIndex: -1 }), this.setOpen(!1, t);
        return;
      }
      if (this.opened) {
        const n = A(
          e,
          t.keyCode,
          t.altKey,
          this.buttonsData.length
        );
        o.focusedIndex = n;
        const d = t.keyCode === r.up || t.keyCode === r.down || t.keyCode === r.left || t.keyCode === r.right;
        !t.altKey && (d || t.keyCode === r.home || t.keyCode === r.end) && t.preventDefault();
      }
      this.setState(o);
    }, this.switchFocus = (t) => {
      this.skipFocus = !0, t(), window.setTimeout(() => this.skipFocus = !1, 0);
    }, this.handleFocus = (t) => {
      this.skipFocus || (this.setState({ focused: !0, focusedIndex: this.opened ? 0 : -1 }), h(this.props.onFocus, t, this, void 0));
    }, this.handleButtonBlur = (t) => {
      this.opened || (this.setState({ focused: !1 }), h(this.props.onBlur, t, this, void 0));
    }, this.handleMenuBlur = (t) => {
      this.skipFocus || (this.setState({ focused: !1, focusedIndex: -1 }), h(this.props.onBlur, t, this, void 0), setTimeout(() => {
        this.setOpen(!1, t);
      }, 0));
    }, this.setOpen = (t, e) => {
      this.opened !== t && (this.openedDuringOnChange = t, this.setState({ opened: t }), e ? this.dispatchPopupEvent(e, t) : this.openedDuringOnChange = void 0);
    }, this.onItemClick = (t, e) => {
      this.setState({ focusedIndex: -1 }), this.dispatchClickEvent(t, e), this.setOpen(!1, t);
    }, this.onItemDown = (t) => {
      l(document) === this.list && t.preventDefault();
    }, this.mouseDown = (t) => {
      t.preventDefault();
      const e = l(document);
      this.element && e !== this.element && e !== this.list && this.element.focus();
    }, this.onPopupClose = (t) => {
      var o;
      const e = l(document);
      this.element && this.element.removeAttribute("tabindex"), (e === this.list || (o = this.list) != null && o.contains(e)) && this.switchFocus(() => {
        this.element && this.element.focus({ preventScroll: !0 });
      }), this.props.popupSettings && this.props.popupSettings.onClose && this.props.popupSettings.onClose.call(void 0, t);
    }, this.listRef = (t) => {
      this.list = t, t && this.state.focused && this.switchFocus(() => {
        t.focus({ preventScroll: !0 }), this.element && (this.element.tabIndex = -1);
      });
    }, this.onClickMainButton = (t) => {
      if (!this.buttonsData.length)
        return;
      const e = !this.opened;
      this.setState({
        focused: !0,
        focusedIndex: e ? 0 : -1
      }), this.setOpen(e, t);
    }, this.dispatchPopupEvent = (t, e) => {
      h(e ? this.props.onOpen : this.props.onClose, t, this, void 0), this.openedDuringOnChange = void 0;
    }, K(U);
  }
  get guid() {
    return this.props.id + "-accessibility-id";
  }
  get opened() {
    return this.openedDuringOnChange !== void 0 ? this.openedDuringOnChange : this.props.opened === void 0 ? this.state.opened : this.props.opened;
  }
  /**
   * @hidden
   */
  render() {
    const i = this.isRtl(), t = i ? "rtl" : void 0, {
      id: e,
      style: o,
      tabIndex: n,
      disabled: d,
      size: f,
      rounded: g,
      fillMode: C,
      themeColor: k,
      ariaLabel: y,
      title: b,
      accessKey: I,
      icon: D,
      svgIcon: w,
      iconClass: S,
      buttonClass: x,
      className: B,
      imageUrl: O,
      startIcon: F,
      endIcon: E
    } = this.props;
    return this.buttonsData = this.props.items || p.Children.toArray(this.props.children).filter((a) => a && a.type === R).map((a) => a.props), /* @__PURE__ */ p.createElement(p.Fragment, null, /* @__PURE__ */ p.createElement(
      v,
      {
        id: e,
        size: f,
        style: o,
        rounded: g,
        fillMode: C,
        themeColor: k,
        onClick: this.onClickMainButton,
        onMouseDown: this.mouseDown,
        onKeyDown: this.onKeyDown,
        onFocus: this.handleFocus,
        onBlur: this.handleButtonBlur,
        "aria-disabled": d ? "true" : void 0,
        tabIndex: n,
        accessKey: I,
        icon: D,
        svgIcon: w,
        iconClass: S,
        className: c(
          x,
          B,
          "k-menu-button",
          // Used for a11y testing.
          "k-dropdown-button",
          // Used because of the old name of the component. Have the same styles as 'k-menu-button'.
          { "k-focus": this.state.focused },
          { "k-disabled": d }
        ),
        imageUrl: O,
        dir: t,
        ref: (a) => this.mainButton = a && a.element,
        type: "button",
        "aria-haspopup": "menu",
        "aria-expanded": this.opened ? "true" : "false",
        "aria-label": y,
        "aria-controls": this.opened ? this.guid : void 0,
        title: b,
        startIcon: F,
        endIcon: E
      },
      this.props.text
    ), this.renderPopup(i));
  }
  /**
   * @hidden
   */
  componentDidMount() {
    (this.props.dir === void 0 && this.isRtl() || this.opened) && this.forceUpdate();
  }
  /**
   * The DOM element of main button.
   */
  get element() {
    return this.mainButton;
  }
  dispatchClickEvent(i, t) {
    this.isItemDisabled(t) || h(
      this.props.onItemClick,
      i,
      this,
      {
        item: this.buttonsData[t],
        itemIndex: t
      }
    );
  }
  renderPopup(i) {
    const { popupSettings: t = {}, id: e } = this.props, { focusedIndex: o } = this.state;
    return /* @__PURE__ */ p.createElement(
      N,
      {
        anchor: this.mainButton,
        show: this.opened,
        animate: t.animate,
        popupClass: c("k-menu-popup", t.popupClass),
        anchorAlign: t.anchorAlign || T(i),
        popupAlign: t.popupAlign || $(i),
        style: i ? { direction: "rtl" } : void 0,
        onClose: this.onPopupClose
      },
      /* @__PURE__ */ p.createElement(
        "ul",
        {
          role: "menu",
          id: this.guid,
          "aria-labelledby": e,
          tabIndex: -1,
          "aria-activedescendant": o >= 0 ? `${this.guid}-${o}` : void 0,
          ref: this.listRef,
          onKeyDown: this.onKeyDown,
          onBlur: this.handleMenuBlur,
          className: c("k-group k-menu-group k-reset", {
            [`k-menu-group-${M.sizeMap[this.props.size] || this.props.size}`]: this.props.size
          })
        },
        this.renderChildItems()
      )
    );
  }
  renderChildItems() {
    const { item: i, itemRender: t, textField: e } = this.props;
    return this.buttonsData.length > 0 ? this.buttonsData.map((o, n) => /* @__PURE__ */ p.createElement(
      z,
      {
        className: "k-menu-item",
        dataItem: o,
        textField: e,
        focused: this.state.focusedIndex === n,
        onClick: this.onItemClick,
        onDown: this.onItemDown,
        render: t,
        item: i,
        index: n,
        key: n,
        id: `${this.guid}-${n}`
      }
    )) : null;
  }
  isItemDisabled(i) {
    return this.buttonsData[i] ? this.buttonsData[i].disabled : this.props.disabled;
  }
  isRtl() {
    return this.props.dir !== void 0 ? this.props.dir === "rtl" : !!this.mainButton && getComputedStyle(this.mainButton).direction === "rtl";
  }
};
u.propTypes = {
  accessKey: s.string,
  ariaLabel: s.string,
  title: s.string,
  onFocus: s.func,
  onBlur: s.func,
  onItemClick: s.func,
  onOpen: s.func,
  onClose: s.func,
  items: s.arrayOf(s.any),
  textField: s.string,
  tabIndex: s.number,
  disabled: s.bool,
  icon: s.string,
  svgIcon: P,
  iconClass: s.string,
  imageUrl: s.string,
  popupSettings: s.object,
  itemRender: s.func,
  item: s.func,
  className: s.string,
  buttonClass: s.string,
  dir: s.string
}, u.defaultProps = {
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  themeColor: "base"
};
let m = u;
export {
  m as DropDownButton
};
