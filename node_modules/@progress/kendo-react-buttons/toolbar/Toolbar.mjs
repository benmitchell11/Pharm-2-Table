/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2024 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as a from "react";
import o from "prop-types";
import { Keys as r, validatePackage as l, classNames as p, kendoThemeMaps as u } from "@progress/kendo-react-common";
import { toolbarButtons as c } from "../util.mjs";
import { packageMetadata as m } from "../package-metadata.mjs";
const h = class h extends a.Component {
  constructor(s) {
    super(s), this._element = null, this.offsetHeight = 0, this.offsetWidth = 0, this.buttons = [], this.focusedSelector = this.selectors.map((t) => t + ":focus").join(","), this.setTabIndex = (t) => {
      const { tabIndex: i = h.defaultProps.tabIndex } = this.props;
      this.buttons.forEach((n, e) => {
        n.tabIndex = e === t ? i : -1;
      });
    }, this.onKeyDown = (t) => {
      const i = t.target;
      if (!(t.keyCode === r.left || t.keyCode === r.right || t.keyCode === r.home || t.keyCode === r.end) || t.defaultPrevented || this.buttons.findIndex((f) => f === i) === -1)
        return;
      const e = this.focusedIndex;
      t.keyCode === r.left ? this.focusButton(e, e === 0 ? this.buttons.length - 1 : e - 1) : this.focusButton(e, e === this.buttons.length - 1 ? 0 : e + 1), t.keyCode === r.home && this.focusButton(e, 0), t.keyCode === r.end && this.focusButton(e, this.buttons.length - 1);
    }, this.onWindowResize = (t) => {
      const i = this.element;
      if (!i)
        return;
      const n = i.offsetWidth, e = i.offsetHeight;
      if (this.offsetWidth !== n || this.offsetHeight !== e) {
        this.offsetWidth = n, this.offsetHeight = e;
        const f = { offsetWidth: this.offsetWidth, offsetHeight: this.offsetHeight };
        this.props.onResize && this.props.onResize.call(void 0, { target: this, ...f, nativeEvent: t });
      }
    }, l(m);
  }
  get selectors() {
    return this.props.buttons || c;
  }
  get focusedIndex() {
    const s = this.element && this.element.querySelector(this.focusedSelector);
    return Math.max(0, this.buttons.findIndex((t) => t === s));
  }
  /**
   * Returns the HTML element of the Toolbar component.
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  componentDidMount() {
    window.addEventListener("resize", this.onWindowResize);
    const s = this.element;
    s && (this.offsetWidth = s.offsetWidth, this.offsetHeight = s.offsetHeight, this.props.keyboardNavigation !== !1 && (this.buttons = Array.from(s.querySelectorAll(this.selectors.join(","))), this.setTabIndex(0)));
  }
  /**
   * @hidden
   */
  componentDidUpdate() {
    const s = this.element;
    !s || this.props.keyboardNavigation === !1 || (this.buttons = Array.from(s.querySelectorAll(this.selectors.join(","))), this.setTabIndex(this.focusedIndex));
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    window.removeEventListener("resize", this.onWindowResize), this.buttons.length = 0;
  }
  /**
   * @hidden
   */
  render() {
    return /* @__PURE__ */ a.createElement(
      "div",
      {
        id: this.props.id,
        "aria-label": this.props.ariaLabel,
        className: p(
          "k-toolbar",
          {
            [`k-toolbar-${u.sizeMap[this.props.size] || this.props.size}`]: this.props.size
          },
          this.props.className
        ),
        style: this.props.style,
        role: this.props.role !== void 0 ? this.props.role || void 0 : "toolbar",
        dir: this.props.dir,
        ref: (s) => this._element = s,
        onKeyDown: this.props.keyboardNavigation !== !1 ? this.onKeyDown : void 0
      },
      this.props.children
    );
  }
  focusButton(s, t) {
    const { tabIndex: i = h.defaultProps.tabIndex } = this.props, n = this.buttons[t];
    if (n) {
      n.tabIndex = i, n.focus();
      const e = this.buttons[s];
      e && (e.tabIndex = -1);
    }
  }
};
h.propTypes = {
  tabIndex: o.number,
  dir: o.string,
  keyboardNavigation: o.bool,
  style: o.object,
  className: o.string,
  role: o.string,
  onResize: o.func,
  buttons: o.arrayOf(o.string),
  size: o.oneOf([null, "small", "medium", "large"])
}, h.defaultProps = {
  tabIndex: 0,
  size: "medium"
};
let d = h;
export {
  d as Toolbar
};
